// Code for testing all sorts of SQLite interfaces.
#include "Test.cu.h"

#pragma region Tests

// This is a copy of the first part of the SqliteDb structure in tclsqlite.c.  We need it here so that the get_sqlite_pointer routine
// can extract the sqlite3* pointer from an existing Tcl SQLite connection.
struct TestCtx
{
	Context *Ctx;
};

// Convert text generated by the "%p" conversion format back into a pointer.
__device__ static int testHexToInt(int h)
{
	if (h >= '0' && h <= '9')
		return h - '0';
	else if (h >= 'a' && h <= 'f')
		return h - 'a' + 10;
	else
	{
		_assert(h >= 'A' && h <= 'F');
		return h - 'A' + 10;
	}
}

__device__ void *sqlite3TestTextToPtr(const char *z)
{
	if (z[0] == '0' && z[1] == 'x')
		z += 2;
	uint64 v = 0;
	while (*z)
	{
		v = (v<<4) + testHexToInt(*z);
		z++;
	}
	void *p;
	if (sizeof(p) == sizeof(v))
		_memcpy(&p, &v, sizeof(p));
	else
	{
		uint32 v2;
		_assert(sizeof(p) == sizeof(v2));
		v2 = (uint32)v;
		_memcpy(&p, &v2, sizeof(p));
	}
	return p;
}

// A TCL command that returns the address of the sqlite* pointer for an sqlite connection instance.  Bad things happen if the
// input is not an sqlite connection.
__device__ static int get_sqlite_pointer(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "SQLITE-CONNECTION");
		return JIM_ERROR;
	}
	Jim_CmdInfo cmdInfo;
	if (!Jim_GetCommandInfo(interp, args[1], &cmdInfo))
	{
		Jim_AppendResult(interp, "command not found: ", Jim_String(args[1]), nullptr);
		return JIM_ERROR;
	}
	struct TclContext *p = (struct TclContext *)cmdInfo.objClientData;
	char b[100];
	_sprintf(b, "%p", p->Ctx);
	if (_strncmp(b, "0x", 2))
		_sprintf(b, "0x%p", p->Ctx);
	Jim_AppendResult(interp, b, nullptr);
	return JIM_OK;
}

// Decode a pointer to an sqlite3 object.
__device__ int GetDbPointer(Jim_Interp *interp, const char *a, Context **ctx)
{
	struct TclContext *p;
	Jim_CmdInfo cmdInfo;
	if (Jim_GetCommandInfoStr(interp, a, &cmdInfo))
	{
		p = (struct TclContext *)cmdInfo.objClientData;
		*ctx = p->Ctx;
	}
	else
		*ctx = (Context *)sqlite3TestTextToPtr(a);
	return JIM_OK;
}

__device__ const char *sqlite3TestErrorName(int rc)
{
	const char *name = 0;
	switch (rc)
	{
	case RC_OK:						name = "SQLITE_OK";                break;
	case RC_ERROR:					name = "SQLITE_ERROR";             break;
	case RC_INTERNAL:				name = "SQLITE_INTERNAL";          break;
	case RC_PERM:					name = "SQLITE_PERM";              break;
	case RC_ABORT:					name = "SQLITE_ABORT";             break;
	case RC_BUSY:					name = "SQLITE_BUSY";              break;
	case RC_LOCKED:					name = "SQLITE_LOCKED";            break;
	case RC_LOCKED_SHAREDCACHE:		name = "SQLITE_LOCKED_SHAREDCACHE";break;
	case RC_NOMEM:					name = "SQLITE_NOMEM";             break;
	case RC_READONLY:				name = "SQLITE_READONLY";          break;
	case RC_INTERRUPT:				name = "SQLITE_INTERRUPT";         break;
	case RC_IOERR:					name = "SQLITE_IOERR";             break;
	case RC_CORRUPT:				name = "SQLITE_CORRUPT";           break;
	case RC_NOTFOUND:				name = "SQLITE_NOTFOUND";          break;
	case RC_FULL:					name = "SQLITE_FULL";              break;
	case RC_CANTOPEN:				name = "SQLITE_CANTOPEN";          break;
	case RC_PROTOCOL:				name = "SQLITE_PROTOCOL";          break;
	case RC_EMPTY:					name = "SQLITE_EMPTY";             break;
	case RC_SCHEMA:					name = "SQLITE_SCHEMA";            break;
	case RC_TOOBIG:					name = "SQLITE_TOOBIG";            break;
	case RC_CONSTRAINT:				name = "SQLITE_CONSTRAINT";        break;
	case RC_CONSTRAINT_UNIQUE:		name = "SQLITE_CONSTRAINT_UNIQUE"; break;
	case RC_CONSTRAINT_TRIGGER:		name = "SQLITE_CONSTRAINT_TRIGGER";break;
	case RC_CONSTRAINT_FOREIGNKEY:	name = "SQLITE_CONSTRAINT_FOREIGNKEY"; break;
	case RC_CONSTRAINT_CHECK:		name = "SQLITE_CONSTRAINT_CHECK";  break;
	case RC_CONSTRAINT_PRIMARYKEY:	name = "SQLITE_CONSTRAINT_PRIMARYKEY"; break;
	case RC_CONSTRAINT_NOTNULL:		name = "SQLITE_CONSTRAINT_NOTNULL";break;
	case RC_CONSTRAINT_COMMITHOOK:	name = "SQLITE_CONSTRAINT_COMMITHOOK"; break;
	case RC_CONSTRAINT_VTAB:		name = "SQLITE_CONSTRAINT_VTAB";   break;
	case RC_CONSTRAINT_FUNCTION:	name = "SQLITE_CONSTRAINT_FUNCTION";break;
	case RC_MISMATCH:				name = "SQLITE_MISMATCH";          break;
	case RC_MISUSE:					name = "SQLITE_MISUSE";            break;
	case RC_NOLFS:					name = "SQLITE_NOLFS";             break;
	case RC_AUTH:					name = "SQLITE_AUTH";              break;
	case RC_FORMAT:					name = "SQLITE_FORMAT";            break;
	case RC_RANGE:					name = "SQLITE_RANGE";             break;
	case RC_NOTADB:					name = "SQLITE_NOTADB";            break;
	case RC_ROW:					name = "SQLITE_ROW";               break;
	case RC_DONE:					name = "SQLITE_DONE";              break;
	case RC_IOERR_READ:				name = "SQLITE_IOERR_READ";        break;
	case RC_IOERR_SHORT_READ:		name = "SQLITE_IOERR_SHORT_READ";  break;
	case RC_IOERR_WRITE:			name = "SQLITE_IOERR_WRITE";       break;
	case RC_IOERR_FSYNC:			name = "SQLITE_IOERR_FSYNC";       break;
	case RC_IOERR_DIR_FSYNC:		name = "SQLITE_IOERR_DIR_FSYNC";   break;
	case RC_IOERR_TRUNCATE:			name = "SQLITE_IOERR_TRUNCATE";    break;
	case RC_IOERR_FSTAT:			name = "SQLITE_IOERR_FSTAT";       break;
	case RC_IOERR_UNLOCK:			name = "SQLITE_IOERR_UNLOCK";      break;
	case RC_IOERR_RDLOCK:			name = "SQLITE_IOERR_RDLOCK";      break;
	case RC_IOERR_DELETE:			name = "SQLITE_IOERR_DELETE";      break;
	case RC_IOERR_BLOCKED:			name = "SQLITE_IOERR_BLOCKED";     break;
	case RC_IOERR_NOMEM:			name = "SQLITE_IOERR_NOMEM";       break;
	case RC_IOERR_ACCESS:			name = "SQLITE_IOERR_ACCESS";      break;
	case RC_IOERR_CHECKRESERVEDLOCK: name = "SQLITE_IOERR_CHECKRESERVEDLOCK"; break;
	case RC_IOERR_LOCK:				name = "SQLITE_IOERR_LOCK";        break;
	case RC_CORRUPT_VTAB:			name = "SQLITE_CORRUPT_VTAB";      break;
	case RC_READONLY_RECOVERY:		name = "SQLITE_READONLY_RECOVERY"; break;
	case RC_READONLY_CANTLOCK:		name = "SQLITE_READONLY_CANTLOCK"; break;
	case RC_READONLY_ROLLBACK:		name = "SQLITE_READONLY_ROLLBACK"; break;
	default:						name = "SQLITE_Unknown";           break;
	}
	return name;
}
#define t1ErrorName sqlite3TestErrorName

// Convert an sqlite3_stmt* into an sqlite3*.  This depends on the fact that the sqlite3* is the first field in the Vdbe structure.
#define StmtToDb(X) Vdbe::Stmt_Ctx(X)

// Check a return value to make sure it agrees with the results from sqlite3_errcode.
__device__ int sqlite3TestErrCode(Jim_Interp *interp, Context *ctx, int rc)
{
	if (THREADSAFE == 0 && rc != RC_MISUSE && rc != RC_OK && DataEx::ErrCode(ctx) != rc)
	{
		char b[200];
		int r2 = DataEx::ErrCode(ctx);
		_sprintf(b, "error code %s (%d) does not match sqlite3_errcode %s (%d)", t1ErrorName(rc), rc, t1ErrorName(r2), r2);
		Jim_ResetResult(interp);
		Jim_AppendResult(interp, b, nullptr);
		return 1;
	}
	return 0;
}

// Decode a pointer to an sqlite3_stmt object.
__device__ static int getStmtPointer(Jim_Interp *interp, const char *arg, Vdbe **stmt)
{
	*stmt = (Vdbe *)sqlite3TestTextToPtr(arg);
	return JIM_OK;
}

// Generate a text representation of a pointer that can be understood by the GetDbPointer and getVmPointer routines above.
//
// The problem is, on some machines (Solaris) if you do a printf with "%p" you cannot turn around and do a scanf with the same "%p" and
// get your pointer back.  You have to prepend a "0x" before it will work.  Or at least that is what is reported to me (drh).  But this
// behavior varies from machine to machine.  The solution used her is to test the string right after it is generated to see if it can be
// understood by scanf, and if not, try prepending an "0x" to see if that helps.  If nothing works, a fatal error is generated.
__device__ int sqlite3TestMakePointerStr(Jim_Interp *interp, char *ptr, void *p)
{
	__snprintf(ptr, 100, "%p", p);
	return JIM_OK;
}

// The callback routine for sqlite3_exec_printf().
__device__ static bool exec_printf_cb(void *arg, int argc, char **args, char **name)
{
	TextBuilder *str = (TextBuilder *)arg;
	int i;
	if (str->Index == 0)
		for (i = 0; i < argc; i++)
			str->AppendElement(name[i] ? name[i] : "NULL");
	for (i = 0; i < argc; i++)
		str->AppendElement(args[i] ? args[i] : "NULL");
	return false;
}

// The I/O tracing callback.
#if !defined(OMIT_TRACE) && defined(ENABLE_IOTRACE)
__device__ static FILE *_iotrace_file = nullptr;
__device__ static void io_trace_callback(const char *fmt, ...)
{
	_va_list args;
	_va_start(args, fmt);
	_vfprintf(_iotrace_file, fmt, args);
	_va_end(args);
	_fflush(_iotrace_file);
}
#endif

// Usage:  io_trace FILENAME
//
// Turn I/O tracing on or off.  If FILENAME is not an empty string, I/O tracing begins going into FILENAME. If FILENAME is an empty string, I/O tracing is turned off.
__device__ static int test_io_trace(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#if !defined(OMIT_TRACE) && defined(ENABLE_IOTRACE)
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FILENAME\"", nullptr);
		return JIM_ERROR;
	}
	if (_iotrace_file)
	{
		if (_iotrace_file != _stdout && _iotrace_file != _stderr)
			_fclose(_iotrace_file);
		_iotrace_file = nullptr;
		sqlite3IoTrace = nullptr;
	}
	char *path = Jim_String(args[1]);
	if (path[0])
	{
		if (!_strcmp(path, "stdout")) _iotrace_file = _stdout;
		else if (_strcmp(path, "stderr")) _iotrace_file = _stderr;
		else _iotrace_file = _fopen(path, "w");
		sqlite3IoTrace = _io_trace_callback;
	}
#endif
	return JIM_OK;
}

// Usage:  sqlite3_exec_printf  DB  FORMAT  STRING
//
// Invoke the sqlite3_exec_printf() interface using the open database DB.  The SQL is the string FORMAT.  The format string should contain
// one %s or %q.  STRING is the value inserted into %s or %q.
__device__ static int test_exec_printf(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB FORMAT STRING", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	char *sql = _mprintf(Jim_String(args[2]), Jim_String(args[3]));
	TextBuilder str;
	TextBuilder::Init(&str);
	char *err = nullptr;
	RC rc = DataEx::Exec(ctx, sql, exec_printf_cb, &str, &err);
	_free(sql);
	char b[30];
	_sprintf(b, "%d", rc);
	Jim_AppendElement(interp, b);
	Jim_AppendElement(interp, rc == RC_OK ? str.ToString() : err);
	str.Reset();
	if (err) _free(err);
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	return JIM_OK;
}

// Usage:  sqlite3_exec_hex  DB  HEX
//
// Invoke the sqlite3_exec() on a string that is obtained by translating HEX into ASCII.  Most characters are translated as is.  %HH becomes a hex character.
__device__ static int test_exec_hex(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB HEX", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	char *hex = (char *)Jim_String(args[2]);
	char sql[500];
	int i, j;
	for (i = j = 0; i < sizeof(sql) && hex[j]; i++, j++)
		if (hex[j] == '%' && hex[j+2] && hex[j+2])
		{
			sql[i] = (testHexToInt(hex[j+1])<<4) + testHexToInt(hex[j+2]);
			j += 2;
		}
		else
			sql[i] = hex[j];
	sql[i] = 0;
	TextBuilder str;
	TextBuilder::Init(&str);
	char *err = nullptr;
	RC rc = DataEx::Exec(ctx, sql, exec_printf_cb, &str, &err);
	char b[30];
	_sprintf(b, "%d", rc);
	Jim_AppendElement(interp, b);
	Jim_AppendElement(interp, rc == RC_OK ? str.ToString() : err);
	str.Reset();
	if (err) _free(err);
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	return JIM_OK;
}

// Usage:  db_enter DB
//         db_leave DB
//
// Enter or leave the mutex on a database connection.
__device__ static int db_enter(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	_mutex_enter(ctx->Mutex);
	return JIM_OK;
}
__device__ static int db_leave(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	_mutex_leave(db->mutex);
	return JIM_OK;
}

// Usage:  sqlite3_exec  DB  SQL
//
// Invoke the sqlite3_exec interface using the open database DB
__device__ static int test_exec(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB SQL", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	char *sql = _mprintf("%s", Jim_String(args[2]));
	int i, j;
	for (i = j = 0; sql[i];)
		if (sql[i]=='%' )
		{
			sql[j++] = (testHexToInt(sql[i+1])<<4) + testHexToInt(sql[i+2]);
			i += 3;
		}
		else
			sql[j++] = sql[i++];
	sql[j] = 0;
	TextBuilder str;
	TextBuilder::Init(&str);
	char *err = nullptr;
	RC rc = DataEx::Exec(ctx, sql, exec_printf_cb, &str, &err);
	_free(sql);
	char b[30];
	_sprintf(b, "%d", rc);
	Jim_AppendElement(interp, b);
	Jim_AppendElement(interp, rc == RC_OK ? str.ToString() : err);
	str.Reset();
	if (err) _free(err);
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	return JIM_OK;
}

// Usage:  sqlite3_exec_nr  DB  SQL
//
// Invoke the sqlite3_exec interface using the open database DB.  Discard all results
__device__ static int test_exec_nr(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	char *err = nullptr;
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB SQL", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::Exec(ctx, Jim_String(args[2]), nullptr, nullptr, &err);
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_z_test  SEPARATOR  ARG0  ARG1 ...
//
// Test the %z format of sqlite_mprintf().  Use multiple mprintf() calls to concatenate arg0 through argn using separator as the separator.
// Return the result.
__device__ static int test_mprintf_z(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	char *result = nullptr;
	for (int i = 2; i < argc && (i == 2 || result); i++)
		result = _mprintf("%z%s%s", result, Jim_String(args[1]), Jim_String(args[i]));
	Jim_AppendResult(interp, result, nullptr);
	_free(result);
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_n_test  STRING
//
// Test the %n format of sqlite_mprintf().  Return the length of the input string.
__device__ static int test_mprintf_n(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	int n = 0;
	char *str = _mprintf("%s%n", Jim_String(args[1]), &n);
	_free(str);
	Jim_SetResultInt(interp, n);
	return JIM_OK;
}

// Usage:  sqlite3_snprintf_int  SIZE FORMAT  INT
//
// Test the of sqlite3_snprintf() routine.  SIZE is the size of the output buffer in bytes.  The maximum size is 100.  FORMAT is the
// format string.  INT is a single integer argument.  The FORMAT string must require no more than this one integer argument.  If
// You pass in a format string that requires more than one argument, bad things will happen.
__device__ static int test_snprintf_int(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	int n = _atoi(Jim_String(args[1]));
	const char *format = Jim_String(args[2]);
	int a1 = _atoi(Jim_String(args[3]));
	char str[100];
	if (n > sizeof(str)) n = sizeof(str);
	__snprintf(str, sizeof(str), "abcdefghijklmnopqrstuvwxyz");
	__snprintf(str, n, format, a1);
	Jim_AppendResult(interp, str, nullptr);
	return JIM_OK;
}

#ifndef OMIT_GET_TABLE

// Usage:  sqlite3_get_table_printf  DB  FORMAT  STRING  ?--no-counts?
//
// Invoke the sqlite3_get_table_printf() interface using the open database DB.  The SQL is the string FORMAT.  The format string should contain
// one %s or %q.  STRING is the value inserted into %s or %q.
__device__ static int test_get_table_printf(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4 && argc != 5)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB FORMAT STRING ?COUNT?", nullptr);
		return JIM_ERROR;
	}
	int resCount = -1;
	if (argc == 5)
		if (Jim_GetInt(interp, args[4], &resCount)) return JIM_ERROR;
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	TextBuilder str;
	TextBuilder::Init(&str);
	char *sql = _mprintf(Jim_String(args[2]), Jim_String(args[3]));
	RC rc;
	char **results;
	int rows, cols;
	char *err = nullptr;
	if (argc == 5)
		rc = Table::GetTable(ctx, sql, &results, nullptr, nullptr, &err);
	else
	{
		rc = Table::GetTable(ctx, sql, &results, &rows, &cols, &err);
		resCount = (rows+1)*cols;
	}
	_free(sql);
	char b[30];
	_sprintf(b, "%d", rc);
	Jim_AppendElement(interp, b);
	if (rc == RC_OK)
	{
		if (argc == 4)
		{
			_sprintf(b, "%d", rows);
			Jim_AppendElement(interp, b);
			_sprintf(b, "%d", cols);
			Jim_AppendElement(interp, b);
		}
		for (int i = 0; i < resCount; i++)
			Jim_AppendElement(interp, results[i] ? results[i] : "NULL");
	}
	else
		Jim_AppendElement(interp, err);
	Table::FreeTable(results);
	if (err) _free(err);
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	return JIM_OK;
}

#endif

// Usage:  sqlite3_last_insert_rowid DB
//
// Returns the integer ROWID of the most recent insert.
__device__ static int test_last_rowid(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB\"", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	char b[30];
	_sprintf(b, "%lld", DataEx::CtxLastInsertRowid(ctx));
	Jim_AppendResult(interp, b, nullptr);
	return RC_OK;
}

// Usage:  sqlite3_key DB KEY
//
// Set the codec key.
__device__ static int test_key(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifdef HAS_CODEC
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FILENAME\"", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *zKey = argv[2];
	int nKey = _strlen(zKey);
	sqlite3_key(ctx, zKey, nKey);
#endif
	return JIM_OK;
}

// Usage:  sqlite3_rekey DB KEY
//
// Change the codec key.
__device__ static int test_rekey(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifdef HAS_CODEC
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FILENAME\"", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *key = Jim_String(args[2]);
	int keyLength = _strlen(key);
	sqlite3_rekey(ctx, key, keyLength);
#endif
	return JIM_OK;
}

// Usage:  sqlite3_close DB
//
// Closes the database opened by sqlite3_open.
__device__ static int sqlite_test_close(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FILENAME\"", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::Close(ctx);
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	return JIM_OK;
}

// Implementation of the x_coalesce() function.
// Return the first argument non-NULL argument.
__device__ static void t1_ifnullFunc(FuncContext *fctx, int argc, Mem **args)
{
	for (int i = 0; i < argc; i++)
		if (Vdbe::Value_Type(args[i]) != TYPE_NULL)
		{
			int n = Vdbe::Value_Bytes(args[i]);
			Vdbe::Result_Text(fctx, (char *)Vdbe::Value_Text(args[i]), n, DESTRUCTOR_TRANSIENT);
			break;
		}
}

// These are test functions.
// hex8() interprets its argument as UTF8 and returns a hex encoding.
// hex16le() interprets its argument as UTF16le and returns a hex encoding.
__device__ static void hex8Func(FuncContext *fctx, int argc, Mem **args)
{
	const unsigned char *z = Vdbe::Value_Text(args[0]);
	int i;
	char b[200];
	for (i = 0; i < sizeof(b)/2 - 2 && z[i]; i++)
		_sprintf(&b[i*2], "%02x", z[i]&0xff);
	b[i*2] = 0;
	Vdbe::Result_Text(fctx, (char *)b, -1, DESTRUCTOR_TRANSIENT);
}
#ifndef OMIT_UTF16
__device__ static void hex16Func(FuncContext *fctx, int argc, Mem **args)
{
	const unsigned short int *z = (const unsigned short int *)Vdbe::Value_Text16(args[0]);
	int i;
	char b[400];
	for (i = 0; i < sizeof(b)/4 - 4 && z[i]; i++)
		_sprintf(&b[i*4], "%04x", z[i]&0xff);
	b[i*4] = 0;
	Vdbe::Result_Text(fctx, (char *)b, -1, DESTRUCTOR_TRANSIENT);
}
#endif

// A structure into which to accumulate text.
struct dstr
{
	int Alloc;  // Space allocated
	int Used;   // Space used
	char *z;	// The space
};

// Append text to a dstr
__device__ static void dstrAppend(struct dstr *p, const char *z, int divider)
{
	int n = (int)_strlen(z);
	if (p->Used + n + 2 > p->Alloc)
	{
		p->Alloc = p->Alloc*2 + n + 200;
		char *newZ = (char *)_realloc(p->z, p->Alloc);
		if  (!newZ)
		{
			_free(p->z);
			_memset(p, 0, sizeof(*p));
			return;
		}
		p->z = newZ;
	}
	if (divider && p->Used > 0)
		p->z[p->Used++] = divider;
	_memcpy(&p->z[p->Used], z, n+1);
	p->Used += n;
}

// Invoked for each callback from sqlite3ExecFunc
__device__ static bool execFuncCallback(void *p, int argc, char **args, char **notUsed)
{
	struct dstr *p2 = (struct dstr *)p;
	for (int i = 0; i < argc; i++)
	{
		if (args[i] == 0) dstrAppend(p2, "NULL", ' ');
		else dstrAppend(p2, args[i], ' ');
	}
	return false;
}

// Implementation of the x_sqlite_exec() function.  This function takes a single argument and attempts to execute that argument as SQL code.
// This is illegal and should set the SQLITE_MISUSE flag on the database.
//
// 2004-Jan-07:  We have changed this to make it legal to call sqlite3_exec() from within a function call.  
// 
// This routine simulates the effect of having two threads attempt to use the same database at the same time.
__device__ static void sqlite3ExecFunc(FuncContext *fctx, int argc, Mem **args)
{
	struct dstr x;
	_memset(&x, 0, sizeof(x));
	DataEx::Exec((Context *)Vdbe::User_Data(fctx), (char *)Vdbe::Value_Text(args[0]), execFuncCallback, &x, 0);
	Vdbe::Result_Text(fctx, x.z, x.Used, DESTRUCTOR_TRANSIENT);
	_free(x.z);
}

// Implementation of tkt2213func(), a scalar function that takes exactly one argument. It has two interesting features:
//
// * It calls sqlite3_value_text() 3 times on the argument sqlite3_value*.
//   If the three pointers returned are not the same an SQL error is raised.
//
// * Otherwise it returns a copy of the text representation of its argument in such a way as the VDBE representation is a Mem* cell 
//   with the MEM_Term flag clear. 
//
// Ticket #2213 can therefore be tested by evaluating the following SQL expression:
//
//   tkt2213func(tkt2213func('a string'));
__device__ static void tkt2213Function(FuncContext *fctx, int argc, Mem **args)
{
	int textLength = Vdbe::Value_Bytes(args[0]);
	unsigned char const *text1 = Vdbe::Value_Text(args[0]);
	unsigned char const *text2 = Vdbe::Value_Text(args[0]);
	unsigned char const *text3 = Vdbe::Value_Text(args[0]);

	if (text1 != text2 || text2 != text3)
		Vdbe::Result_Error(fctx, "tkt2213 is not fixed", -1);
	else
	{
		char *copy = (char *)_alloc(textLength);
		_memcpy(copy, text1, textLength);
		Vdbe::Result_Text(fctx, copy, textLength, _free);
	}
}

// The following SQL function takes 4 arguments.  The 2nd and 4th argument must be one of these strings:  'text', 'text16',
// or 'blob' corresponding to API functions
//
//      sqlite3_value_text()
//      sqlite3_value_text16()
//      sqlite3_value_blob()
//
// The third argument is a string, either 'bytes' or 'bytes16' or 'noop', corresponding to APIs:
//
//      sqlite3_value_bytes()
//      sqlite3_value_bytes16()
//      noop
//
// The APIs designated by the 2nd through 4th arguments are applied to the first argument in order.  If the pointers returned by the
// second and fourth are different, this routine returns 1.  Otherwise, this routine returns 0.
//
// This function is used to test to see when returned pointers from the _text(), _text16() and _blob() APIs become invalidated.
__device__ static void ptrChngFunction(FuncContext *fctx, int argc, Mem **args)
{
	const void *p1, *p2;
	if (argc != 4) return;
	const char *cmd = (const char *)Vdbe::Value_Text(args[1]);
	if (!cmd) return;
	if (!_strcmp(cmd, "text")) p1 = (const void *)Vdbe::Value_Text(args[0]);
#ifndef OMIT_UTF16
	else if (!_strcmp(cmd, "text16")) p1 = (const void *)Vdbe::Value_Text16(args[0]);
#endif
	else if (!_strcmp(cmd, "blob")) p1 = (const void *)Vdbe::Value_Blob(args[0]);
	else return;
	cmd = (const char *)Vdbe::Value_Text(args[2]);
	if (!cmd) return;
	if (!_strcmp(cmd, "bytes")) Vdbe::Value_Bytes(args[0]);
#ifndef OMIT_UTF16
	else if (!_strcmp(cmd, "bytes16")) Vdbe::Value_Bytes16(args[0]);
#endif
	else if (!_strcmp(cmd, "noop")) { } // do nothing
	else return;
	cmd = (const char *)Vdbe::Value_Text(args[3]);
	if (!cmd) return;
	if (!_strcmp(cmd, "text")) p2 = (const void *)Vdbe::Value_Text(args[0]);
#ifndef OMIT_UTF16
	else if (!_strcmp(cmd, "text16")) p2 = (const void *)Vdbe::Value_Text16(args[0]);
#endif
	else if (!_strcmp(cmd, "blob")) p2 = (const void *)Vdbe::Value_Blob(args[0]);
	else return;
	Vdbe::Result_Int(fctx, p1 != p2);
}

// Usage:  sqlite_test_create_function DB
//
// Call the sqlite3_create_function API on the given database in order to create a function named "x_coalesce".  This function does the same thing
// as the "coalesce" function.  This function also registers an SQL function named "x_sqlite_exec" that invokes sqlite3_exec().  Invoking sqlite3_exec()
// in this way is illegal recursion and should raise an SQLITE_MISUSE error. The effect is similar to trying to use the same database connection from
// two threads at the same time.
//
// The original motivation for this routine was to be able to call the sqlite3_create_function function while a query is in progress in order
// to test the SQLITE_MISUSE detection logic.
__device__ static int test_create_function(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB\"", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::CreateFunction(ctx, "x_coalesce", -1, TEXTENCODE_ANY, 0, t1_ifnullFunc, 0, 0);
	if (rc == RC_OK)
		rc = DataEx::CreateFunction(ctx, "hex8", 1, TEXTENCODE_ANY, 0, hex8Func, 0, 0);
#ifndef OMIT_UTF16
	if (rc == RC_OK)
		rc = DataEx::CreateFunction(ctx, "hex16", 1, TEXTENCODE_ANY, 0, hex16Func, 0, 0);
#endif
	if (rc == RC_OK)
		rc = DataEx::CreateFunction(ctx, "tkt2213func", 1, TEXTENCODE_ANY, 0, tkt2213Function, 0, 0);
	if (rc == RC_OK)
		rc = DataEx::CreateFunction(ctx, "pointer_change", 4, TEXTENCODE_ANY, 0, ptrChngFunction, 0, 0);

#ifndef OMIT_UTF16
	// Use the sqlite3_create_function16() API here. Mainly for fun, but also because it is not tested anywhere else.
	if (rc == RC_OK)
	{
		_mutex_enter(ctx->Mutex);
		Mem *val = Vdbe::ValueNew(ctx);
		Vdbe::ValueSetStr(val, -1, "x_sqlite_exec", TEXTENCODE_UTF8, DESTRUCTOR_STATIC);
		const void *utf16 = Vdbe::ValueText(val, TEXTENCODE_UTF16NATIVE);
		if (ctx->MallocFailed)
			rc = RC_NOMEM;
		else
			rc = DataEx::CreateFunction16(ctx, utf16, 1, TEXTENCODE_UTF16, ctx, sqlite3ExecFunc, 0, 0);
		Vdbe::ValueFree(val);
		_mutex_leave(ctx->Mutex);
	}
#endif

	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), 0);
	return JIM_OK;
}

// Routines to implement the x_count() aggregate function.
//
// x_count() counts the number of non-null arguments.  But there are some twists for testing purposes.
//
// If the argument to x_count() is 40 then a UTF-8 error is reported on the step function.  If x_count(41) is seen, then a UTF-16 error
// is reported on the step function.  If the total count is 42, then a UTF-8 error is reported on the finalize function.
typedef struct t1CountCtx t1CountCtx;
struct t1CountCtx
{
	int n;
};

__device__ static void t1CountStep(FuncContext *fctx, int argc, Mem **args)
{
	t1CountCtx *p = (t1CountCtx *)Vdbe::Aggregate_Context(fctx, sizeof(*p));
	if ((argc == 0 || Vdbe::Value_Type(args[0]) != TYPE_NULL) && p)
		p->n++;
	if (argc > 0)
	{
		int v = Vdbe::Value_Int(args[0]);
		if (v == 40)
		{
			Vdbe::Result_Error(fctx, "value of 40 handed to x_count", -1);
#ifndef OMIT_UTF16
		}
		else if (v == 41)
		{
			const char utf16ErrMsg[] = { 0, 0x61, 0, 0x62, 0, 0x63, 0, 0, 0};
			Vdbe::Result_Error16(fctx, &utf16ErrMsg[1-TYPE_BIGENDIAN], -1);
#endif
		}
	}
}   
__device__ static void t1CountFinalize(FuncContext *fctx)
{
	t1CountCtx *p = (t1CountCtx *)Vdbe::Aggregate_Context(fctx, sizeof(*p));
	if (p)
	{
		if (p->n == 42)
			Vdbe::Result_Error(fctx, "x_count totals to 42", -1);
		else
			Vdbe::Result_Int(fctx, p ? p->n : 0);
	}
}

//#ifndef OMIT_DEPRECATED
//__device__ static void legacyCountStep(FuncContext *fctx, int argc, Mem **args) { } // no-op
//__device__ static void legacyCountFinalize(FuncContext *fctx)
//{
//	Vdbe::Result_Int(fctx, Vdbe::AggregateCount(fctx));
//}
//#endif

// Usage:  sqlite3_create_aggregate DB
//
// Call the sqlite3_create_function API on the given database in order to create a function named "x_count".  This function is similar
// to the built-in count() function, with a few special quirks for testing the sqlite3_result_error() APIs.
//
// The original motivation for this routine was to be able to call the sqlite3_create_aggregate function while a query is in progress in order
// to test the SQLITE_MISUSE detection logic.  See misuse.test.
//
// This routine was later extended to test the use of sqlite3_result_error() within aggregate functions.
//
// Later: It is now also extended to register the aggregate function "legacy_count()" with the supplied database handle. This is used
// to test the deprecated sqlite3_aggregate_count() API.
__device__ static int test_create_aggregate(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FILENAME\"", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::CreateFunction(ctx, "x_count", 0, TEXTENCODE_UTF8, nullptr, nullptr, t1CountStep, t1CountFinalize);
	if (rc == RC_OK)
		rc = DataEx::CreateFunction(ctx, "x_count", 1, TEXTENCODE_UTF8, nullptr, nullptr, t1CountStep, t1CountFinalize);
#ifndef OMIT_DEPRECATED
	//if (rc == RC_OK)
	//	rc = DataEx::CreateFunction(ctx, "legacy_count", 0, TEXTENCODE_ANY, nullptr, nullptr, legacyCountStep, legacyCountFinalize);
#endif
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	Jim_SetResultString(interp, t1ErrorName(rc), -1);
	return JIM_OK;
}

// Usage:  printf TEXT
//
// Send output to printf.  Use this rather than puts to merge the output in the correct sequence with debugging printfs inserted into C code.
// Puts uses a separate buffer and debugging statements will be out of sequence if it is used.
__device__ static int test_printf(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " TEXT\"", nullptr);
		return JIM_ERROR;
	}
	_printf("%s\n", Jim_String(args[1]));
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_int FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three integer arguments
__device__ static int sqlite3_mprintf_int(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FORMAT INT INT INT\"", nullptr);
		return JIM_ERROR;
	}
	int a[3];
	for (int i = 2; i < 5; i++)
		if (Jim_GetInt(interp, args[i], &a[i-2])) return JIM_ERROR;
	char *z = _mprintf(Jim_String(args[1]), a[0], a[1], a[2]);
	Jim_AppendResult(interp, z, nullptr);
	_free(z);
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_int64 FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three 64-bit integer arguments
__device__ static int sqlite3_mprintf_int64(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FORMAT INT INT INT\"", nullptr);
		return JIM_ERROR;
	}
	int64 a[3];
	for (int i = 2; i < 5; i++)
		if (__atoi64(Jim_String(args[i]), &a[i-2], 1000000, TEXTENCODE_UTF8))
		{
			Jim_AppendResult(interp, "argument is not a valid 64-bit integer", nullptr);
			return JIM_ERROR;
		}
		char *z = _mprintf(Jim_String(args[1]), a[0], a[1], a[2]);
		Jim_AppendResult(interp, z, nullptr);
		_free(z);
		return JIM_OK;
}

// Usage:  sqlite3_mprintf_long FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three long integer arguments.   This might be the same as sqlite3_mprintf_int or sqlite3_mprintf_int64, depending on platform.
__device__ static int sqlite3_mprintf_long(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FORMAT INT INT INT\"", nullptr);
		return JIM_ERROR;
	}
	long int a[3];
	int b[3];
	for (int i = 2; i < 5; i++)
	{
		if (Jim_GetInt(interp, args[i], &b[i-2])) return JIM_ERROR;
		a[i-2] = (long int)b[i-2];
		a[i-2] &= (((uint64)1)<<(sizeof(int)*8))-1;
	}
	char *z = _mprintf(Jim_String(args[1]), a[0], a[1], a[2]);
	Jim_AppendResult(interp, z, nullptr);
	_free(z);
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_str FORMAT INTEGER INTEGER STRING
//
// Call mprintf with two integer arguments and one string argument
__device__ static int sqlite3_mprintf_str(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc < 4 || argc > 5)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FORMAT INT INT ?STRING?\"", nullptr);
		return JIM_ERROR;
	}
	int a[3];
	for (int i = 2; i < 4; i++)
		if (Jim_GetInt(interp, args[i], &a[i-2])) return JIM_ERROR;
	char *z = _mprintf(Jim_String(args[1]), a[0], a[1], argc > 4 ? args[4] : nullptr);
	Jim_AppendResult(interp, z, nullptr);
	_free(z);
	return JIM_OK;
}

// Usage:  sqlite3_snprintf_str INTEGER FORMAT INTEGER INTEGER STRING
//
// Call mprintf with two integer arguments and one string argument
__device__ static int sqlite3_snprintf_str(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc < 5 || argc > 6)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " INT FORMAT INT INT ?STRING?\"", nullptr);
		return JIM_ERROR;
	}
	int n;
	if (Jim_GetInt(interp, args[1], &n)) return JIM_ERROR;
	if (n < 0)
	{
		Jim_AppendResult(interp, "N must be non-negative", nullptr);
		return JIM_ERROR;
	}
	int a[3];
	for (int i = 3; i < 5; i++)
		if (Jim_GetInt(interp, args[i], &a[i-3])) return JIM_ERROR;
	char *z = (char *)_alloc(n+1);
	__snprintf(z, n, Jim_String(args[2]), a[0], a[1], argc > 4 ? Jim_String(args[5]) : nullptr);
	Jim_AppendResult(interp, z, nullptr);
	_free(z);
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_double FORMAT INTEGER INTEGER DOUBLE
//
// Call mprintf with two integer arguments and one double argument
__device__ static int sqlite3_mprintf_double(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FORMAT INT INT DOUBLE\"", nullptr);
		return JIM_ERROR;
	}
	int a[3];
	for (int i = 2; i < 4; i++)
		if (Jim_GetInt(interp, args[i], &a[i-2])) return JIM_ERROR;
	double r;
	if (Jim_GetDouble(interp, args[4], &r)) return JIM_ERROR;
	char *z = _mprintf(Jim_String(args[1]), a[0], a[1], r);
	Jim_AppendResult(interp, z, nullptr);
	_free(z);
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_scaled FORMAT DOUBLE DOUBLE
//
// Call mprintf with a single double argument which is the product of the two arguments given above.  This is used to generate overflow and underflow
// doubles to test that they are converted properly.
__device__ static int sqlite3_mprintf_scaled(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FORMAT DOUBLE DOUBLE\"", nullptr);
		return JIM_ERROR;
	}
	double r[2];
	for (int i = 2; i < 4; i++)
		if (Jim_GetDouble(interp, args[i], &r[i-2])) return JIM_ERROR;
	char *z = _mprintf(Jim_String(args[1]), r[0]*r[1]);
	Jim_AppendResult(interp, z, nullptr);
	_free(z);
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_stronly FORMAT STRING
//
// Call mprintf with a single double argument which is the product of the two arguments given above.  This is used to generate overflow and underflow
// doubles to test that they are converted properly.
__device__ static int sqlite3_mprintf_stronly(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FORMAT STRING\"", 0);
		return JIM_ERROR;
	}
	char *z = _mprintf(Jim_String(args[1]), Jim_String(args[2]));
	Jim_AppendResult(interp, z, nullptr);
	_free(z);
	return JIM_OK;
}

// Usage:  sqlite3_mprintf_hexdouble FORMAT HEX
//
// Call mprintf with a single double argument which is derived from the hexadecimal encoding of an IEEE double.
__device__ static int sqlite3_mprintf_hexdouble(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FORMAT STRING\"", nullptr);
		return JIM_ERROR;
	}
	unsigned int x1, x2;
	if (_sscanf(Jim_String(args[2]), "%08x%08x", &x2, &x1) != 2)
	{
		Jim_AppendResult(interp, "2nd argument should be 16-characters of hex", nullptr);
		return JIM_ERROR;
	}
	uint64 d = x2;
	d = (d<<32) + x1;
	double r;
	_memcpy(&r, &d, sizeof(r));
	char *z = _mprintf(Jim_String(args[1]), r);
	Jim_AppendResult(interp, z, nullptr);
	_free(z);
	return JIM_OK;
}

// Usage: sqlite3_enable_shared_cache ?BOOLEAN?
#if !defined(OMIT_SHARED_CACHE)
__device__ static int test_enable_shared(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2 && argc != 1)
	{
		Jim_WrongNumArgs(interp, 1, args, "?BOOLEAN?");
		return JIM_ERROR;
	}
	bool ret = SysEx_GlobalStatics.SharedCacheEnabled;
	if (argc == 2)
	{
		bool enable;
		if (Jim_GetBoolean(interp, args[1], &enable)) return JIM_ERROR;
		RC rc = Btree::EnableSharedCache(enable);
		if (rc != RC_OK)
		{
			Jim_SetResultString(interp, (char *)DataEx::ErrStr(rc), -1);
			return JIM_ERROR;
		}
	}
	Jim_SetResultBool(interp, ret);
	return JIM_OK;
}
#endif

// Usage: sqlite3_extended_result_codes   DB    BOOLEAN
__device__ static int test_extended_result_codes(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB BOOLEAN");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	bool enable;
	if (Jim_GetBoolean(interp, args[2], &enable)) return JIM_ERROR;
	DataEx::ExtendedResultCodes(ctx, enable);
	return JIM_OK;
}

// Usage: sqlite3_libversion_number
__device__ static int test_libversion_number(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	Jim_SetResultInt(interp, CORE_VERSION_NUMBER);
	return JIM_OK;
}

// Usage: sqlite3_table_column_metadata DB dbname tblname colname
#ifdef ENABLE_COLUMN_METADATA
__device__ static int test_table_column_metadata(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB dbname tblname colname");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, args[1], &ctx)) return JIM_ERROR;
	const char *dbName = args[2];
	const char *tableName = args[3];
	const char *colName = args[4];
	if (!_strlen(dbName)) dbName = nullptr;

	const char *datatype;
	const char *collseq;
	int notnull;
	int primarykey;
	int autoincrement;
	RC rc = Table::Column_Metadata(ctx, dbName, tableName, colName, &datatype, &collseq, &notnull, &primarykey, &autoincrement);

	if (rc != RC_OK)
	{
		Jim_AppendResult(interp, DataEx::ErrMsg(ctx), nullptr);
		return JIM_ERROR;
	}
	Jim_Obj *r = Jim_NewObj();
	Jim_ListAppendElement(nullptr, r, Jim_NewStringObj(datatype, -1));
	Jim_ListAppendElement(nullptr, r, Jim_NewStringObj(collseq, -1));
	Jim_ListAppendElement(nullptr, r, Jim_NewIntObj(notnull));
	Jim_ListAppendElement(nullptr, r, Jim_NewIntObj(primarykey));
	Jim_ListAppendElement(nullptr, r, Jim_NewIntObj(autoincrement));
	Jim_SetObjResult(interp, r);
	return JIM_OK;
}
#endif

#ifndef OMIT_INCRBLOB
__device__ static int blobHandleFromObj(Jim_Interp *interp, Jim_Obj *arg, Blob **blob)
{
	int n;
	char *z = (char *)Jim_GetString(arg, &n);
	if (n == 0)
		*blob = nullptr;
	else
	{
		int notUsed;
		Jim_Channel channel = Jim_GetChannel(interp, z, &notUsed);
		if (!channel) return JIM_ERROR;
		Jim_Flush(channel);
		Jim_Seek(channel, 0, SEEK_SET);
		ClientData instanceData = Jim_GetChannelInstanceData(channel);
		*blob = *((Blob **)instanceData);
	}
	return JIM_OK;
}

// sqlite3_blob_bytes  CHANNEL
__device__ static int test_blob_bytes(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "CHANNEL");
		return JIM_ERROR;
	}
	Blob *blob;
	if (blobHandleFromObj(interp, args[1], &blob)) return JIM_ERROR;
	int bytes = Vdbe::Blob_Bytes(blob);
	Jim_SetResult(interp, Jim_NewIntObj(interp, bytes));
	return JIM_OK;
}

// sqlite3_blob_close  CHANNEL
__device__ static int test_blob_close(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "CHANNEL");
		return JIM_ERROR;
	}
	Blob *blob;
	if (blobHandleFromObj(interp, args[1], &blob)) return JIM_ERROR;
	Vdbe::Blob_Close(blob);
	return JIM_OK;
}

// sqlite3_blob_read  CHANNEL OFFSET N
//
//   This command is used to test the sqlite3_blob_read() in ways that the Jim channel interface does not. The first argument should
//   be the name of a valid channel created by the [incrblob] method of a database handle. This function calls sqlite3_blob_read()
//   to read N bytes from offset OFFSET from the underlying SQLite blob handle.
//
//   On success, a byte-array object containing the read data is returned. On failure, the interpreter result is set to the
//   text representation of the returned error code (i.e. "SQLITE_NOMEM") and a Jim exception is thrown.
__device__ static int test_blob_read(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_WrongNumArgs(interp, 1, args, "CHANNEL OFFSET N");
		return JIM_ERROR;
	}
	Blob *blob;
	if (blobHandleFromObj(interp, args[1], &blob)) return JIM_ERROR;
	int bytes;
	int offset;
	if (Jim_GetInt(interp, args[2], &offset) != JIM_OK || Jim_GetInt(interp, args[3], &bytes) != JIM_OK) return JIM_ERROR;
	unsigned char *buf = 0;
	if (bytes > 0)
		buf = (unsigned char *)Jim_Alloc(bytes);
	RC rc = Vdbe::Blob_Read(blob, buf, bytes, offset);
	if (rc == RC_OK)
		Jim_SetResult(interp, Jim_NewByteArrayObj(interp, buf, buf));
	else
		Jim_SetResult(interp, (char *)sqlite3TestErrorName(rc), JIM_VOLATILE);
	Jim_Free((char *)buf);
	return (rc == RC_OK ? JIM_OK : JIM_ERROR);
}

// sqlite3_blob_write CHANNEL OFFSET DATA ?NDATA?
//
//   This command is used to test the sqlite3_blob_write() in ways that the Jim channel interface does not. The first argument should
//   be the name of a valid channel created by the [incrblob] method of a database handle. This function calls sqlite3_blob_write()
//   to write the DATA byte-array to the underlying SQLite blob handle. at offset OFFSET.
//
//   On success, an empty string is returned. On failure, the interpreter result is set to the text representation of the returned error code 
//   (i.e. "SQLITE_NOMEM") and a Jim exception is thrown.
__device__ static int test_blob_write(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4 && argc != 5)
	{
		Jim_WrongNumArgs(interp, 1, args, "CHANNEL OFFSET DATA ?NDATA?");
		return JIM_ERROR;
	}
	Blob *blob;
	if (blobHandleFromObj(interp, args[1], &blob)) return JIM_ERROR;
	int offset;
	if (Jim_GetInt(interp, args[2], &offset) != JIM_OK) return JIM_ERROR;
	int bufLength;
	char *buf = Jim_GetByteArray(interp, args[3], &bufLength);
	if (argc == 5 && Jim_GetInt(interp, args[4], &bufLength)) return JIM_ERROR;
	RC rc = Vdbe::Blob_Write(blob, buf, bufLength, offset);
	if (rc != RC_OK)
		Jim_SetResult(interp, (char *)sqlite3TestErrorName(rc), JIM_VOLATILE);
	return (rc == RC_OK ? JIM_OK : JIM_ERROR);
}

__device__ static int test_blob_reopen(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_WrongNumArgs(interp, 1, args, "CHANNEL ROWID");
		return JIM_ERROR;
	}
	Blob *blob;
	if (blobHandleFromObj(interp, args[1], &blob)) return JIM_ERROR;
	int64 rowid;
	if (Jim_GetWide(interp, args[2], &rowid)) return JIM_ERROR;
	RC rc = Vdbe::Blob_Reopen(blob, rowid);
	if (rc != RC_OK)
		Jim_SetResult(interp, (char *)sqlite3TestErrorName(rc), JIM_VOLATILE);
	return (rc == RC_OK ? JIM_OK : JIM_ERROR);
}
#endif

// Usage: sqlite3_create_collation_v2 DB-HANDLE NAME CMP-PROC DEL-PROC
//
//   This Jim proc is used for testing the experimental sqlite3_create_collation_v2() interface.
struct TestCollationX
{
	Jim_Interp *Interp;
	Jim_Obj *Cmp;
	Jim_Obj *Del;
};
typedef struct TestCollationX TestCollationX;
__device__ static void testCreateCollationDel(void *ctx)
{
	TestCollationX *p = (TestCollationX *)ctx;
	Jim_Interp *interp = p->Interp;
	int rc = Jim_EvalObj(interp, p->Del);
	if (rc != JIM_OK)
		Jim_BackgroundError(p->Interp);
	Jim_DecrRefCount(interp, p->Cmp);
	Jim_DecrRefCount(interp, p->Del);
	_free((void *)p);
}
__device__ static int testCreateCollationCmp(void *ctx, int leftLength, const void *left, int rightLength, const void *right)
{
	TestCollationX *p = (TestCollationX *)ctx;
	Jim_Interp *interp = p->Interp;
	Jim_Obj *script = Jim_DuplicateObj(interp, p->Cmp);
	Jim_IncrRefCount(script);
	Jim_ListAppendElement(nullptr, script, Jim_NewStringObj(interp, (char *)left, leftLength));
	Jim_ListAppendElement(nullptr, script, Jim_NewStringObj(interp, (char *)right, rightLength));
	int res = 0;
	if (Jim_EvalObj(p->Interp, script) != JIM_OK || Jim_GetInt(p->Interp, p->Interp->result, &res) != JIM_OK)
		Jim_BackgroundError(p->Interp);
	Jim_DecrRefCount(interp, script);
	return res;
}
__device__ static int test_create_collation_v2(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB-HANDLE NAME CMP-PROC DEL-PROC");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	TestCollationX *p = (TestCollationX *)_alloc(sizeof(TestCollationX));
	p->Cmp = args[3];
	p->Del = args[4];
	p->Interp = interp;
	Jim_IncrRefCount(p->Cmp);
	Jim_IncrRefCount(p->Del);
	RC rc = DataEx::CreateCollation_v2(ctx, Jim_String(args[2]), (TEXTENCODE)16, (void *)p, testCreateCollationCmp, testCreateCollationDel);
	if (rc != RC_MISUSE)
	{
		Jim_AppendResult(interp, "sqlite3_create_collate_v2() failed to detect an invalid encoding", nullptr);
		return JIM_ERROR;
	}
	rc = DataEx::CreateCollation_v2(ctx, Jim_String(args[2]), TEXTENCODE_UTF8, (void *)p, testCreateCollationCmp, testCreateCollationDel);
	return JIM_OK;
}

// USAGE: sqlite3_create_function_v2 DB NAME NARG ENC ?SWITCHES?
//
// Available switches are:
//
//   -func    SCRIPT
//   -step    SCRIPT
//   -final   SCRIPT
//   -destroy SCRIPT
typedef struct CreateFunctionV2 CreateFunctionV2;
struct CreateFunctionV2
{
	Jim_Interp *Interp;
	Jim_Obj *Func; // Script for function invocation
	Jim_Obj *Step; // Script for agg. step invocation
	Jim_Obj *Final; // Script for agg. finalization invocation
	Jim_Obj *Destroy; // Destructor script
};
__device__ static void cf2Func(FuncContext *fctx, int argc, Mem **args) { }
__device__ static void cf2Step(FuncContext *fctx, int argc, Mem **args) { }
__device__ static void cf2Final(FuncContext *fctx) { }
__device__ static void cf2Destroy(void *user)
{
	CreateFunctionV2 *p = (CreateFunctionV2 *)user;
	Jim_Interp *interp = p->Interp;
	if (p->Interp && p->Destroy)
	{
		int rc = Jim_EvalObj(p->Interp, p->Destroy);
		if (rc != JIM_OK) Jim_BackgroundError(p->Interp);
	}
	if (p->Func) Jim_DecrRefCount(interp, p->Func); 
	if (p->Step) Jim_DecrRefCount(interp, p->Step); 
	if (p->Final) Jim_DecrRefCount(interp, p->Final); 
	if (p->Destroy) Jim_DecrRefCount(interp, p->Destroy); 
	_free(p);
}
__constant__ struct EncTable
{
	const char *EncName;
	int Enc;
} _encs[] = {
	{"utf8",    TEXTENCODE_UTF8 },
	{"utf16",   TEXTENCODE_UTF16 },
	{"utf16le", TEXTENCODE_UTF16LE },
	{"utf16be", TEXTENCODE_UTF16BE },
	{"any",     TEXTENCODE_ANY },
	{"0", 0 }
};
__device__ static int test_create_function_v2(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc < 5 || (argc % 2) == 0)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB NAME NARG ENC SWITCHES...");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *funcName = Jim_String(args[2]);
	int argc2;
	int enc;
	if (Jim_GetInt(interp, args[3], &argc2)) return JIM_ERROR;
	if (Jim_GetEnumFromStruct(interp, args[4], (const void **)_encs, sizeof(_encs[0]), &enc, "encoding", 0)) return JIM_ERROR;
	enc = _encs[enc].Enc;

	CreateFunctionV2 *p = (CreateFunctionV2 *)_alloc(sizeof(CreateFunctionV2));
	_assert(p);
	_memset(p, 0, sizeof(CreateFunctionV2));
	p->Interp = interp;
	for (int i = 5; i < argc; i+=2)
	{
		int switchId;
		const char *switchName[] = {"-func", "-step", "-final", "-destroy", 0};
		if (Jim_GetEnum(interp, args[i], switchName, &switchId, "switch", 0))
		{
			_free(p);
			return JIM_ERROR;
		}
		switch (switchId)
		{
		case 0: p->Func = args[i+1]; break;
		case 1: p->Step = args[i+1]; break;
		case 2: p->Final = args[i+1]; break;
		case 3: p->Destroy = args[i+1]; break;
		}
	}
	if (p->Func) p->Func = Jim_DuplicateObj(interp, p->Func); 
	if (p->Step) p->Step = Jim_DuplicateObj(interp, p->Step); 
	if (p->Final) p->Final = Jim_DuplicateObj(interp, p->Final); 
	if (p->Destroy) p->Destroy = Jim_DuplicateObj(interp, p->Destroy); 
	if (p->Func) Jim_IncrRefCount(p->Func); 
	if (p->Step) Jim_IncrRefCount(p->Step); 
	if (p->Final) Jim_IncrRefCount(p->Final); 
	if (p->Destroy) Jim_IncrRefCount(p->Destroy); 
	RC rc = DataEx::CreateFunction_v2(ctx, funcName, argc2, (TEXTENCODE)enc, (void *)p, 
		(p->Func ? cf2Func : nullptr),
		(p->Step ? cf2Step : nullptr),
		(p->Final ? cf2Final : nullptr),
		cf2Destroy);
	if (rc != RC_OK)
	{
		Jim_ResetResult(interp);
		Jim_AppendResult(interp, sqlite3TestErrorName(rc), nullptr);
		return JIM_ERROR;
	}
	return JIM_OK;
}

// Usage: sqlite3_load_extension DB-HANDLE FILE ?PROC?
__device__ static int test_load_extension(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4 && argc != 3)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB-HANDLE FILE ?PROC?");
		return JIM_ERROR;
	}
	char *dbName = (char *)Jim_String(args[1]);
	char *fileName = (char *)Jim_String(args[2]);
	char *procName = (argc == 4 ? (char *)Jim_String(args[3]) : nullptr);
	// Extract the C database handle from the Tcl command name
	Jim_CmdInfo cmdInfo;
	if (!Jim_GetCommandInfo(interp, args[1], &cmdInfo))
	{
		Jim_AppendResult(interp, "command not found: ", dbName, nullptr);
		return JIM_ERROR;
	}
	Context *ctx = ((struct TclContext *)cmdInfo.objClientData)->Ctx;
	_assert(ctx);

	// Call the underlying C function. If an error occurs, set rc to JIM_ERROR and load any error string into the interpreter. If no  error occurs, set rc to JIM_OK.
	int rc;
	char *err = nullptr;
#ifdef OMIT_LOAD_EXTENSION
	rc = (int)RC_ERROR;
	err = _mprintf("this build omits sqlite3_load_extension()");
#else
	rc = (int)DataEx::LoadExtension(ctx, fileName, procName, &err);
#endif
	if (rc != RC_OK)
	{
		Jim_SetResultString(interp, (err ? err : ""), -1);
		rc = JIM_ERROR;
	}
	else
		rc = JIM_OK;
	_free(err);
	return rc;
}

// Usage: sqlite3_enable_load_extension DB-HANDLE ONOFF
__device__ static int test_enable_load(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB-HANDLE ONOFF");
		return JIM_ERROR;
	}
	const char *dbName = Jim_String(args[1]);

	// Extract the C database handle from the Tcl command name
	Jim_CmdInfo cmdInfo;
	if (!Jim_GetCommandInfo(interp, args[1], &cmdInfo))
	{
		Jim_AppendResult(interp, "command not found: ", dbName, nullptr);
		return JIM_ERROR;
	}
	Context *ctx = ((struct TclContext *)cmdInfo.objClientData)->Ctx;
	_assert(ctx);

	// Get the onoff parameter
	bool onoff;
	if (Jim_GetBoolean(interp, args[2], &onoff)) return JIM_ERROR;

#ifdef OMIT_LOAD_EXTENSION
	Jim_AppendResult(interp, "this build omits sqlite3_load_extension()");
	return JIM_ERROR;
#else
	DataEx::EnableLoadExtension(ctx, onoff);
	return JIM_OK;
#endif
}

// Usage:  sqlite_abort
//
// Shutdown the process immediately.  This is not a clean shutdown. This command is used to test the recoverability of a database in the event of a program crash.
__device__ static int sqlite_abort(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#if defined(_MSC_VER)
	// We do this, otherwise the test will halt with a popup message that we have to click away before the test will continue.
	_set_abort_behavior(0, _CALL_REPORTFAULT);
#endif
	_exit(255);
	_assert(interp == 0); // This will always fail
	return JIM_OK;
}

// The following routine is a user-defined SQL function whose purpose is to test the sqlite_set_result() API.
__device__ static void testFunc(FuncContext *fctx, int argc, Mem **args)
{
	while (argc >= 2)
	{
		const char *arg0 = (char *)Vdbe::Value_Text(args[0]);
		if (arg0)
		{
			if (!_strcmp(arg0, "int")) Vdbe::Result_Int(fctx, Vdbe::Value_Int(args[1]));
			else if (!_strcmp(arg0, "int64"))  Vdbe::Result_Int64(fctx, Vdbe::Value_Int64(args[1]));
			else if (!_strcmp(arg0, "string")) Vdbe::Result_Text(fctx, (char *)Vdbe::Value_Text(args[1]), -1, DESTRUCTOR_TRANSIENT);
			else if (!_strcmp(arg0, "double")) Vdbe::Result_Double(fctx, Vdbe::Value_Double(args[1]));
			else if (!_strcmp(arg0, "null")) Vdbe::Result_Null(fctx);
			else if (!_strcmp(arg0, "value")) Vdbe::Result_Value(fctx, args[Vdbe::Value_Int(args[1])]);
			else goto error_out;
		}
		else goto error_out;
		argc -= 2;
		args += 2;
	}
	return;
error_out:
	Vdbe::Result_Error(fctx, "first argument should be one of: int int64 string double null value", -1);
}

// Usage:   sqlite_register_test_function  DB  NAME
//
// Register the test SQL function on the database DB under the name NAME.
__device__ static int test_register_func(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB FUNCTION-NAME", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::CreateFunction(ctx, Jim_String(args[2]), -1, TEXTENCODE_UTF8, nullptr, testFunc, nullptr, nullptr);
	if (rc != 0)
	{
		Jim_AppendResult(interp, DataEx::ErrStr(rc), nullptr);
		return JIM_ERROR;
	}
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	return JIM_OK;
}

// Usage:  sqlite3_finalize  STMT 
//
// Finalize a statement handle.
__device__ static int test_finalize(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " <STMT>", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	Context *ctx = (stmt ? StmtToDb(stmt) : nullptr);
	RC rc = Vdbe::Finalize(stmt);
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	if (ctx && sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	return JIM_OK;
}

// Usage:  sqlite3_stmt_status  STMT  CODE  RESETFLAG
//
// Get the value of a status counter from a statement.
__constant__ static const struct {
	const char *Name;
	Vdbe::STMTSTATUS OP;
} _ops[] = {
	{ "SQLITE_STMTSTATUS_FULLSCAN_STEP",   Vdbe::STMTSTATUS::STMTSTATUS_FULLSCAN_STEP },
	{ "SQLITE_STMTSTATUS_SORT",            Vdbe::STMTSTATUS::STMTSTATUS_SORT },
	{ "SQLITE_STMTSTATUS_AUTOINDEX",       Vdbe::STMTSTATUS::STMTSTATUS_AUTOINDEX },
};
__device__ static int test_stmt_status(void * clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_WrongNumArgs(interp, 1, args, "STMT PARAMETER RESETFLAG");
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	const char *opName = Jim_String(args[2]);
	int i, op;
	for (i = 0; i < _lengthof(_ops); i++)
	{
		if (!_strcmp(_ops[i].Name, opName))
		{
			op = (int)_ops[i].OP;
			break;
		}
	}
	if (i >= _lengthof(_ops))
		if (Jim_GetInt(interp, args[2], &op)) return JIM_ERROR;
	bool resetFlag;
	if (Jim_GetBoolean(interp, args[3], &resetFlag)) return JIM_ERROR;
	int value = Vdbe::Stmt_Status(stmt, op, resetFlag);
	Jim_SetResultInt(interp, value);
	return JIM_OK;
}

// Usage:  sqlite3_next_stmt  DB  STMT
//
// Return the next statment in sequence after STMT.
__device__ static int test_next_stmt(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB STMT", nullptr);
		return JIM_ERROR;
	}
	Context *ctx = nullptr;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[2]), &stmt)) return JIM_ERROR;
	stmt = Vdbe::Stmt_Next(ctx, stmt);
	if (stmt)
	{
		char buf[50];
		if (sqlite3TestMakePointerStr(interp, buf, stmt)) return JIM_ERROR;
		Jim_AppendResult(interp, buf, nullptr);
	}
	return JIM_OK;
}

// Usage:  sqlite3_stmt_readonly  STMT
//
// Return true if STMT is a NULL pointer or a pointer to a statement that is guaranteed to leave the database unmodified.
__device__ static int test_stmt_readonly(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	bool rc = Vdbe::Stmt_Readonly(stmt);
	Jim_SetResultBool(interp, rc);
	return JIM_OK;
}

// Usage:  sqlite3_stmt_busy  STMT
//
// Return true if STMT is a non-NULL pointer to a statement that has been stepped but not to completion.
__device__ static int test_stmt_busy(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	bool rc = Vdbe::Stmt_Busy(stmt);
	Jim_SetResultBool(interp, rc);
	return JIM_OK;
}

// Usage:  uses_stmt_journal  STMT
//
// Return true if STMT uses a statement journal.
__device__ static int uses_stmt_journal(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	Vdbe::Stmt_Readonly(stmt);
	Jim_SetResultBool(interp, (bool)((Vdbe *)stmt)->UsesStmtJournal);
	return JIM_OK;
}

// Usage:  sqlite3_reset  STMT 
//
// Reset a statement handle.
__device__ static int test_reset(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " <STMT>", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	RC rc = Vdbe::Reset(stmt);
	if (stmt && sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	//if (rc) return JIM_ERROR;
	return JIM_OK;
}

// Usage:  sqlite3_expired STMT 
//
// Return TRUE if a recompilation of the statement is recommended.
__device__ static int test_expired(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_DEPRECATED
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " <STMT>", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	Jim_SetResultBool(interp, stmt->Expired);
#endif
	return JIM_OK;
}

// Usage:  sqlite3_transfer_bindings FROMSTMT TOSTMT
//
// Transfer all bindings from FROMSTMT over to TOSTMT
__device__ static int test_transfer_bind(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_DEPRECATED
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " FROM-STMT TO-STMT", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt1, *stmt2;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt1)) return JIM_ERROR;
	if (getStmtPointer(interp, Jim_String(args[2]), &stmt2)) return JIM_ERROR;
	Jim_SetResultInt(interp, Vdbe::TransferBindings(stmt1, stmt2));
#endif
	return JIM_OK;
}

// Usage:  sqlite3_changes DB
//
// Return the number of changes made to the database by the last SQL execution.
__device__ static int test_changes(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	Jim_SetResultInt(interp, DataEx::CtxChanges(ctx));
	return JIM_OK;
}

// This is the "static_bind_value" that variables are bound to when the FLAG option of sqlite3_bind is "static"
__device__ static char *_static_bind_value = 0;
__device__ static int _static_bind_nbyte = 0;

// Usage:  sqlite3_bind  VM  IDX  VALUE  FLAGS
//
// Sets the value of the IDX-th occurance of "?" in the original SQL string.  VALUE is the new value.  If FLAGS=="null" then VALUE is
// ignored and the value is set to NULL.  If FLAGS=="static" then the value is set to the value of a static variable named
// "sqlite_static_bind_value".  If FLAGS=="normal" then a copy of the VALUE is made.  If FLAGS=="blob10" then a VALUE is ignored
// an a 10-byte blob "abc\000xyz\000pq" is inserted.
__device__ static int test_bind(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " VM IDX VALUE (null|static|normal)\"", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int idx;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &idx)) return JIM_ERROR;
	RC rc;
	const char *type = Jim_String(args[4]);
	if (!_strcmp(type, "null")) rc = Vdbe::Bind_Null(stmt, idx);
	else if (!_strcmp(type, "static")) rc = Vdbe::Bind_Text(stmt, idx, _static_bind_value, -1, 0);
	else if (!_strcmp(type, "static-nbytes")) rc = Vdbe::Bind_Text(stmt, idx, _static_bind_value, _static_bind_nbyte, 0);
	else if (!_strcmp(type, "normal")) rc = Vdbe::Bind_Text(stmt, idx, Jim_String(args[3]), -1, DESTRUCTOR_TRANSIENT);
	else if (!_strcmp(type, "blob10")) rc = Vdbe::Bind_Text(stmt, idx, "abc\000xyz\000pq", 10, DESTRUCTOR_STATIC);
	else
	{
		Jim_AppendResult(interp, "4th argument should be " "\"null\" or \"static\" or \"normal\"", nullptr);
		return JIM_ERROR;
	}
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc)
	{
		char buf[50];
		_sprintf(buf, "(%d) ", rc);
		Jim_AppendResult(interp, buf, DataEx::ErrStr(rc), nullptr);
		return JIM_ERROR;
	}
	return JIM_OK;
}

#ifndef OMIT_UTF16
// Usage: add_test_collate <db ptr> <utf8> <utf16le> <utf16be>
//
// This function is used to test that SQLite selects the correct collation sequence callback when multiple versions (for different text encodings)
// are available.
//
// Calling this routine registers the collation sequence "test_collate" with database handle <db>. The second argument must be a list of three
// boolean values. If the first is true, then a version of test_collate is registered for UTF-8, if the second is true, a version is registered for
// UTF-16le, if the third is true, a UTF-16be version is available. Previous versions of test_collate are deleted.
//
// The collation sequence test_collate is implemented by calling the following TCL script:
//
//   "test_collate <enc> <lhs> <rhs>"
//
// The <lhs> and <rhs> are the two values being compared, encoded in UTF-8. The <enc> parameter is the encoding of the collation function that
// SQLite selected to call. The TCL test script implements the "test_collate" proc.
//
// Note that this will only work with one intepreter at a time, as the interp pointer to use when evaluating the TCL script is stored in pTestCollateInterp.
__device__ static Jim_Interp *_testCollateInterp;
__device__ static int test_collate_func(void *ctx, int aLength, const void *a, int bLength, const void *b)
{
	Jim_Interp *interp = _testCollateInterp;
	TEXTENCODE encin = (TEXTENCODE)PTR_TO_INT(ctx);
	Jim_Obj *pX = Jim_NewStringObj(interp, "test_collate", -1);
	Jim_IncrRefCount(pX);
	switch (encin)
	{
	case TEXTENCODE_UTF8: Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, "UTF-8", -1)); break;
	case TEXTENCODE_UTF16LE: Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, "UTF-16LE", -1)); break;
	case TEXTENCODE_UTF16BE: Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, "UTF-16BE", -1)); break;
	default: _assert(false);
	}
	//
	_benignalloc_begin();
	Mem *val = Vdbe::ValueNew(nullptr);
	if (val)
	{
		Vdbe::ValueSetStr(val, aLength, a, encin, DESTRUCTOR_STATIC);
		int n = Vdbe::Value_Bytes(val);
		Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, (char *)Vdbe::Value_Text(val), n));
		Vdbe::ValueSetStr(val, bLength, b, encin, DESTRUCTOR_STATIC);
		n = Vdbe::Value_Bytes(val);
		Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, (char *)Vdbe::Value_Text(val), n));
		Vdbe::ValueFree(val);
	}
	_benignalloc_end();
	Jim_EvalObj(interp, pX);
	Jim_DecrRefCount(interp, pX);
	int res;
	Jim_GetInt(interp, Jim_GetResult(interp), &res);
	return res;
}
__device__ static int test_collate(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5) goto bad_args;
	_testCollateInterp = interp;
	Context *ctx;
	bool val;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	if (Jim_GetBoolean(interp, args[2], &val) != JIM_OK) return JIM_ERROR;
	RC rc = DataEx::CreateCollation(ctx, "test_collate", TEXTENCODE_UTF8, (void *)TEXTENCODE_UTF8, (val ? test_collate_func : nullptr));
	if (rc == RC_OK)
	{
		if (Jim_GetBoolean(interp, args[3], &val) != JIM_OK) return JIM_ERROR;
		rc = DataEx::CreateCollation(ctx, "test_collate", TEXTENCODE_UTF16LE, (void *)TEXTENCODE_UTF16LE, (val ? test_collate_func : nullptr));
		if (Jim_GetBoolean(interp, args[4], &val) != JIM_OK) return JIM_ERROR;
#if 0
		if (sqlite3_iMallocFail > 0) sqlite3_iMallocFail++;
#endif
		_mutex_enter(ctx->Mutex);
		Mem *val2 = Vdbe::ValueNew(ctx);
		Vdbe::ValueSetStr(val2, -1, "test_collate", TEXTENCODE_UTF8, DESTRUCTOR_STATIC);
		const void *utf16 = Vdbe::ValueText(val2, TEXTENCODE_UTF16NATIVE);
		if (ctx->MallocFailed)
			rc = RC_NOMEM;
		else
			rc = DataEx::CreateCollation16(ctx, utf16, TEXTENCODE_UTF16BE, (void *)TEXTENCODE_UTF16BE, (val ? test_collate_func : nullptr));
		Vdbe::ValueFree(val2);
		_mutex_leave(ctx->Mutex);
	}
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	if (rc != RC_OK)
	{
		Jim_AppendResult(interp, sqlite3TestErrorName(rc), nullptr);
		return JIM_ERROR;
	}
	return JIM_OK;
bad_args:
	Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " <DB> <utf8> <utf16le> <utf16be>", nullptr);
	return JIM_ERROR;
}

// When the collation needed callback is invoked, record the name of the requested collating function here.  The recorded name is linked
// to a TCL variable and used to make sure that the requested collation name is correct.
__device__ static char _neededCollation[200];
__device__ static char *_neededCollationIdx = _neededCollation;

// Called when a collating sequence is needed.  Registered using sqlite3_collation_needed16().
__device__ static void test_collate_needed_cb(void *ctx2, Context *ctx, TEXTENCODE textRep, const void *name)
{
	TEXTENCODE enc = CTXENCODE(ctx);
	int i;
	char *z;
	for (z = (char *)name, i = 0; *z || z[1]; z++)
		if (*z) _neededCollation[i++] = *z;
	_neededCollation[i] = 0;
	DataEx::CreateCollation(ctx, "test_collate", CTXENCODE(ctx), INT_TO_PTR(enc), test_collate_func);
}

// Usage: add_test_collate_needed DB
__device__ static int test_collate_needed(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2) goto bad_args;
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::CollationNeeded16(ctx, 0, test_collate_needed_cb);
	_neededCollation[0] = 0;
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	return JIM_OK;
bad_args:
	Jim_WrongNumArgs(interp, 1, args, "DB");
	return JIM_ERROR;
}

// tclcmd:   add_alignment_test_collations  DB
//
// Add two new collating sequences to the database DB
//     utf16_aligned
//     utf16_unaligned
//
// Both collating sequences use the same sort order as BINARY. The only difference is that the utf16_aligned collating
// sequence is declared with the SQLITE_UTF16_ALIGNED flag. Both collating functions increment the unaligned utf16 counter
// whenever they see a string that begins on an odd byte boundary.
__device__ static int _unaligned_string_counter = 0;
__device__ static int alignmentCollFunc(ClientData notUsed, int key1Length, const void *key1, int key2Length, const void *key2)
{
	int n = (key1Length < key2Length ? key1Length : key2Length);
	if (key1Length > 0 && 1==(1&(PTR_TO_INT(key1)))) _unaligned_string_counter++;
	if (key2Length > 0 && 1==(1&(PTR_TO_INT(key2)))) _unaligned_string_counter++;
	int rc = _memcmp(key1, key2, n);
	if (rc == 0)
		rc = key1Length - key2Length;
	return rc;
}
__device__ static int add_alignment_test_collations(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc >= 2)
	{
		Context *ctx;
		if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
		DataEx::CreateCollation(ctx, "utf16_unaligned", TEXTENCODE_UTF16, nullptr, alignmentCollFunc);
		DataEx::CreateCollation(ctx, "utf16_aligned", TEXTENCODE_UTF16_ALIGNED, nullptr, alignmentCollFunc);
	}
	return RC_OK;
}
#endif

// Usage: add_test_function <db ptr> <utf8> <utf16le> <utf16be>
//
// This function is used to test that SQLite selects the correct user function callback when multiple versions (for different text encodings)
// are available.
//
// Calling this routine registers up to three versions of the user function "test_function" with database handle <db>.  If the second argument is
// true, then a version of test_function is registered for UTF-8, if the third is true, a version is registered for UTF-16le, if the fourth is
// true, a UTF-16be version is available.  Previous versions of test_function are deleted.
//
// The user function is implemented by calling the following TCL script:
//   "test_function <enc> <arg>"
//
// Where <enc> is one of UTF-8, UTF-16LE or UTF16BE, and <arg> is the single argument passed to the SQL function. The value returned by
// the TCL script is used as the return value of the SQL function. It is passed to SQLite using UTF-16BE for a UTF-8 test_function(), UTF-8
// for a UTF-16LE test_function(), and UTF-16LE for an implementation that prefers UTF-16BE.
#ifndef OMIT_UTF16
__device__ static void test_function_utf8(FuncContext *fctx, int argc, Mem **args)
{
	Jim_Interp *interp = (Jim_Interp *)Vdbe::User_Data(fctx);
	Jim_Obj *pX = Jim_NewStringObj(interp, "test_function", -1);
	Jim_IncrRefCount(pX);
	Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, "UTF-8", -1));
	Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, (char *)Vdbe::Value_Text(args[0]), -1));
	Jim_EvalObj(interp, pX);
	Jim_DecrRefCount(interp, pX);
	Vdbe::Result_Text(fctx, Jim_String(Jim_GetResult(interp)), -1, DESTRUCTOR_TRANSIENT);
	Mem *val = Vdbe::ValueNew(nullptr);
	Vdbe::ValueSetStr(val, -1, interp->result, TEXTENCODE_UTF8, DESTRUCTOR_STATIC);
	Vdbe::Result_Text16be(fctx, Vdbe::Value_Text16be(val), -1, DESTRUCTOR_TRANSIENT);
	Vdbe::ValueFree(val);
}
__device__ static void test_function_utf16le(FuncContext *fctx, int argc, Mem **args)
{
	Jim_Interp *interp = (Jim_Interp *)Vdbe::User_Data(fctx);
	Jim_Obj *pX = Jim_NewStringObj(interp, "test_function", -1);
	Jim_IncrRefCount(pX);
	Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, "UTF-16LE", -1));
	Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, (char*)Vdbe::Value_Text(args[0]), -1));
	Jim_EvalObj(interp, pX);
	Jim_DecrRefCount(interp, pX);
	Mem *val = Vdbe::ValueNew(nullptr);
	Vdbe::ValueSetStr(val, -1, Jim_String(Jim_GetResult(interp)), TEXTENCODE_UTF8, DESTRUCTOR_STATIC);
	Vdbe::Result_Text(fctx, (char*)Vdbe::Value_Text(val), -1, DESTRUCTOR_TRANSIENT);
	Vdbe::ValueFree(val);
}
__device__ static void test_function_utf16be(FuncContext *fctx,  int argc, Mem **args)
{
	Jim_Interp *interp = (Jim_Interp *)Vdbe::User_Data(fctx);
	Jim_Obj *pX = Jim_NewStringObj(interp, "test_function", -1);
	Jim_IncrRefCount(pX);
	Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, "UTF-16BE", -1));
	Jim_ListAppendElement(interp, pX, Jim_NewStringObj(interp, (char *)Vdbe::Value_Text(args[0]), -1));
	Jim_EvalObj(interp, pX);
	Jim_DecrRefCount(interp, pX);
	Mem *val = Vdbe::ValueNew(nullptr);
	Vdbe::ValueSetStr(val, -1, Jim_String(Jim_GetResult(interp)), TEXTENCODE_UTF8, DESTRUCTOR_STATIC);
	Vdbe::Result_Text16(fctx, Vdbe::Value_Text16le(val), -1, DESTRUCTOR_TRANSIENT);
	Vdbe::Result_Text16be(fctx, Vdbe::Value_Text16le(val), -1, DESTRUCTOR_TRANSIENT);
	Vdbe::Result_Text16le(fctx, Vdbe::Value_Text16le(val), -1, DESTRUCTOR_TRANSIENT);
	Vdbe::ValueFree(val);
}
#endif
__device__ static int test_function(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_UTF16
	if (argc != 5) goto bad_args;
	Context *ctx;
	bool val;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	if (Jim_GetBoolean(interp, args[2], &val) != JIM_OK) return JIM_ERROR;
	if (val)
		DataEx::CreateFunction(ctx, "test_function", 1, TEXTENCODE_UTF8, interp, test_function_utf8, 0, 0);
	if (Jim_GetBoolean(interp, args[3], &val) != JIM_OK) return JIM_ERROR;
	if (val)
		DataEx::CreateFunction(ctx, "test_function", 1, TEXTENCODE_UTF16LE, interp, test_function_utf16le, 0, 0);
	if (Jim_GetBoolean(interp, args[4], &val) != JIM_OK) return JIM_ERROR;
	if (val)
		DataEx::CreateFunction(ctx, "test_function", 1, TEXTENCODE_UTF16BE, interp, test_function_utf16be, 0, 0);
	return JIM_OK;
bad_args:
	Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " <DB> <utf8> <utf16le> <utf16be>", nullptr);
#endif
	return JIM_ERROR;
}

// Usage:         sqlite3_test_errstr <err code>
//
// Test that the english language string equivalents for sqlite error codes are sane. The parameter is an integer representing an sqlite error code.
// The result is a list of two elements, the string representation of the error code and the english language explanation.
__device__ static int test_errstr(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 1)
		Jim_WrongNumArgs(interp, 1, args, "<error code>");
	char *code = (char *)Jim_String(args[1]);
	int i;
	for (i = 0; i < 200; i++)
		if (!_strcmp(t1ErrorName(i), code)) break;
	Jim_SetResultString(interp, (char *)DataEx::ErrStr((RC)i), -1);
	return JIM_OK;
}

// Usage:    breakpoint
//
// This routine exists for one purpose - to provide a place to put a breakpoint with GDB that can be triggered using TCL code.  The use
// for this is when a particular test fails on (say) the 1485th iteration. In the TCL test script, we can add code like this:
//
//     if {$i==1485} breakpoint
//
// Then run testfixture in the debugger and wait for the breakpoint to fire.  Then additional breakpoints can be set to trace down the bug.
__device__ static int test_breakpoint(ClientData notUsed, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	return JIM_OK; // Do nothing
}

// Usage:   sqlite3_bind_zeroblob  STMT IDX N
//
// Test the sqlite3_bind_zeroblob interface.  STMT is a prepared statement. IDX is the index of a wildcard in the prepared statement.  This command
// binds a N-byte zero-filled BLOB to the wildcard.
__device__ static int test_bind_zeroblob(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_WrongNumArgs(interp, 1, args, "STMT IDX N");
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int idx;
	int n;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &idx)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[3], &n)) return JIM_ERROR;
	RC rc = Vdbe::Bind_Zeroblob(stmt, idx, n);
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc != RC_OK)
		return JIM_ERROR;
	return JIM_OK;
}

// Usage:   sqlite3_bind_int  STMT N VALUE
//
// Test the sqlite3_bind_int interface.  STMT is a prepared statement. N is the index of a wildcard in the prepared statement.  This command
// binds a 32-bit integer VALUE to that wildcard.
__device__ static int test_bind_int(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT N VALUE", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int idx;
	int value;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &idx)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[3], &value)) return JIM_ERROR;
	RC rc = Vdbe::Bind_Int(stmt, idx, value);
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc != RC_OK)
		return JIM_ERROR;
	return JIM_OK;
}

// Usage:   sqlite3_bind_int64  STMT N VALUE
//
// Test the sqlite3_bind_int64 interface.  STMT is a prepared statement. N is the index of a wildcard in the prepared statement.  This command
// binds a 64-bit integer VALUE to that wildcard.
__device__ static int test_bind_int64(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT N VALUE", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int idx;
	int64 value;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &idx)) return JIM_ERROR;
	if (Jim_GetWide(interp, args[3], &value)) return JIM_ERROR;
	RC rc = Vdbe::Bind_Int64(stmt, idx, value);
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc != RC_OK)
		return JIM_ERROR;
	return JIM_OK;
}

// Usage:   sqlite3_bind_double  STMT N VALUE
//
// Test the sqlite3_bind_double interface.  STMT is a prepared statement. N is the index of a wildcard in the prepared statement.  This command
// binds a 64-bit integer VALUE to that wildcard.
__constant__ static const struct
{
	const char *Name;	// Name of the special floating point value
	unsigned int Upper; // Upper 32 bits
	unsigned int Lower; // Lower 32 bits
} _specialFps[] = {
	{  "NaN",      0x7fffffff, 0xffffffff },
	{  "SNaN",     0x7ff7ffff, 0xffffffff },
	{  "-NaN",     0xffffffff, 0xffffffff },
	{  "-SNaN",    0xfff7ffff, 0xffffffff },
	{  "+Inf",     0x7ff00000, 0x00000000 },
	{  "-Inf",     0xfff00000, 0x00000000 },
	{  "Epsilon",  0x00000000, 0x00000001 },
	{  "-Epsilon", 0x80000000, 0x00000001 },
	{  "NaN0",     0x7ff80000, 0x00000000 },
	{  "-NaN0",    0xfff80000, 0x00000000 },
};
__device__ static int test_bind_double(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT N VALUE", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int idx;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &idx)) return JIM_ERROR;

	// Intercept the string "NaN" and generate a NaN value for it. All other strings are passed through to Jim_GetDoubleFromObj().
	// Jim_GetDoubleFromObj() should understand "NaN" but some versions contain a bug.
	const char *val = Jim_String(args[3]);
	int i;
	double value;
	for (i = 0; i < _lengthof(_specialFps); i++)
	{
		if (!_strcmp(_specialFps[i].Name, val))
		{
			uint64 x = _specialFps[i].Upper;
			x <<= 32;
			x |= _specialFps[i].Lower;
			_assert(sizeof(value) == 8);
			_assert(sizeof(x) == 8);
			_memcpy(&value, &x, 8);
			break;
		}
	}
	if (i >= _lengthof(_specialFps) && Jim_GetDouble(interp, args[3], &value)) return JIM_ERROR;
	RC rc = Vdbe::Bind_Double(stmt, idx, value);
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc != RC_OK)
		return JIM_ERROR;
	return JIM_OK;
}

// Usage:   sqlite3_bind_null  STMT N
//
// Test the sqlite3_bind_null interface.  STMT is a prepared statement. N is the index of a wildcard in the prepared statement.  This command
// binds a NULL to the wildcard.
__device__ static int test_bind_null(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT N", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int idx;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &idx)) return JIM_ERROR;
	RC rc = Vdbe::Bind_Null(stmt, idx);
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc != RC_OK)
		return JIM_ERROR;
	return JIM_OK;
}

// Usage:   sqlite3_bind_text  STMT N STRING BYTES
//
// Test the sqlite3_bind_text interface.  STMT is a prepared statement. N is the index of a wildcard in the prepared statement.  This command
// binds a UTF-8 string STRING to the wildcard.  The string is BYTES bytes long.
__device__ static int test_bind_text(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT N VALUE BYTES", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int idx;
	int bytes;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &idx)) return JIM_ERROR;
	char *value = (char *)Jim_GetByteArray(args[3], &bytes);
	if (Jim_GetInt(interp, args[4], &bytes)) return JIM_ERROR;
	RC rc = Vdbe::Bind_Text(stmt, idx, value, bytes, DESTRUCTOR_TRANSIENT);
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc != RC_OK)
	{
		Jim_AppendResult(interp, sqlite3TestErrorName(rc), nullptr);
		return JIM_ERROR;
	}
	return JIM_OK;
}

// Usage:   sqlite3_bind_text16 ?-static? STMT N STRING BYTES
//
// Test the sqlite3_bind_text16 interface.  STMT is a prepared statement. N is the index of a wildcard in the prepared statement.  This command
// binds a UTF-16 string STRING to the wildcard.  The string is BYTES bytes long.
__device__ static int test_bind_text16(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_UTF16
	if (argc != 5 && argc != 6)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT N VALUE BYTES", nullptr);
		return JIM_ERROR;
	}
	void (*xDel)(void*) = (argc == 6 ? DESTRUCTOR_STATIC : DESTRUCTOR_TRANSIENT);
	Jim_Obj *oStmt    = args[argc-4];
	Jim_Obj *oN       = args[argc-3];
	Jim_Obj *oString  = args[argc-2];
	Jim_Obj *oBytes   = args[argc-1];
	Vdbe *stmt;
	int idx;
	int bytes;
	if (getStmtPointer(interp, Jim_String(oStmt), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, oN, &idx)) return JIM_ERROR;
	char *value = (char *)Jim_GetByteArray(oString, nullptr);
	if (Jim_GetInt(interp, oBytes, &bytes)) return JIM_ERROR;
	RC rc = Vdbe::Bind_Text16(stmt, idx, (void *)value, bytes, xDel);
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc != RC_OK)
	{
		Jim_AppendResult(interp, sqlite3TestErrorName(rc), nullptr);
		return JIM_ERROR;
	}
#endif
	return JIM_OK;
}

// Usage:   sqlite3_bind_blob ?-static? STMT N DATA BYTES
//
// Test the sqlite3_bind_blob interface.  STMT is a prepared statement. N is the index of a wildcard in the prepared statement.  This command
// binds a BLOB to the wildcard.  The BLOB is BYTES bytes in size.
__device__ static int test_bind_blob(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5 && argc != 6)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT N DATA BYTES", nullptr);
		return JIM_ERROR;
	}
	Destructor_t destructor = DESTRUCTOR_TRANSIENT;
	if (argc == 6)
	{
		destructor = DESTRUCTOR_STATIC;
		args++;
	}
	Vdbe *stmt;
	int idx;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &idx)) return JIM_ERROR;
	const char *value = Jim_String(args[3]);
	int bytes;
	if (Jim_GetInt(interp, args[4], &bytes)) return JIM_ERROR;
	RC rc = Vdbe::Bind_Blob(stmt, idx, value, bytes, destructor);
	if (sqlite3TestErrCode(interp, StmtToDb(stmt), rc)) return JIM_ERROR;
	if (rc != RC_OK)
		return JIM_ERROR;
	return JIM_OK;
}

// Usage:   sqlite3_bind_parameter_count  STMT
//
// Return the number of wildcards in the given statement.
__device__ static int test_bind_parameter_count(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "STMT");
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	Jim_SetResultInt(interp, Vdbe::Bind_ParameterCount(stmt));
	return JIM_OK;
}

// Usage:   sqlite3_bind_parameter_name  STMT  N
//
// Return the name of the Nth wildcard.  The first wildcard is 1. An empty string is returned if N is out of range or if the wildcard
// is nameless.
__device__ static int test_bind_parameter_name(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_WrongNumArgs(interp, 1, args, "STMT N");
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int i;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &i)) return JIM_ERROR;
	Jim_SetResultString(interp, Vdbe::Bind_ParameterName(stmt, i), -1);
	return JIM_OK;
}

// Usage:   sqlite3_bind_parameter_index  STMT  NAME
//
// Return the index of the wildcard called NAME.  Return 0 if there is no such wildcard.
__device__ static int test_bind_parameter_index(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_WrongNumArgs(interp, 1, args, "STMT NAME");
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	Jim_SetResultInt(interp, Vdbe::Bind_ParameterIndex(stmt, Jim_String(args[2])));
	return JIM_OK;
}

// Usage:   sqlite3_clear_bindings STMT
__device__ static int test_clear_bindings(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "STMT");
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	Jim_SetResultInt(interp, stmt->ClearBindings());
	return JIM_OK;
}

// Usage:   sqlite3_sleep MILLISECONDS
__device__ static int test_sleep(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "MILLISECONDS");
		return JIM_ERROR;
	}
	int ms;
	if (Jim_GetInt(interp, args[1], &ms)) return JIM_ERROR;
	Jim_SetResultInt(interp, DataEx::Sleep(ms));
	return JIM_OK;
}

// Usage: sqlite3_extended_errcode DB
//
// Return the string representation of the most recent sqlite3_* API error code. e.g. "SQLITE_ERROR".
__device__ static int test_ex_errcode(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::ExtendedErrCode(ctx);
	Jim_AppendResult(interp, (char *)t1ErrorName(rc), nullptr);
	return JIM_OK;
}


// Usage: sqlite3_errcode DB
//
// Return the string representation of the most recent sqlite3_* API error code. e.g. "SQLITE_ERROR".
__device__ static int test_errcode(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::ErrCode(ctx);
	Jim_AppendResult(interp, (char *)t1ErrorName(rc), nullptr);
	return JIM_OK;
}

// Usage:   sqlite3_errmsg DB
//
// Returns the UTF-8 representation of the error message string for the most recent sqlite3_* API call.
__device__ static int test_errmsg(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *err = DataEx::ErrMsg(ctx);
	Jim_SetResultString(interp, err, -1);
	return JIM_OK;
}

// Usage:   test_errmsg16 DB
//
// Returns the UTF-16 representation of the error message string for the most recent sqlite3_* API call. This is a byte array object at the TCL 
// level, and it includes the 0x00 0x00 terminator bytes at the end of the UTF-16 string.
__device__ static int test_errmsg16(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_UTF16
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const void *err = DataEx::ErrMsg16(ctx);
	int bytes = _strlen16(err);
	Jim_SetResultByteArray(interp, err, bytes);
#endif
	return JIM_OK;
}

// Usage: sqlite3_prepare DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A STMT handle is returned.
__device__ static int test_prepare(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5 && argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB sql bytes ?tailvar?", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	int bytes;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *sql = Jim_String(args[2]);
	if (Jim_GetInt(interp, args[3], &bytes)) return JIM_ERROR;

	Vdbe *stmt = nullptr;
	const char *tail = nullptr;
	RC rc = Prepare::Prepare_(ctx, sql, bytes, &stmt, (argc >= 5 ? &tail : nullptr));
	Jim_ResetResult(interp);
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	if (tail && argc >= 5)
	{
		if (bytes >= 0)
			bytes = bytes - (int)(tail-sql);
		if ((int)_strlen(tail) < bytes)
			bytes = (int)_strlen(tail);
		Jim_SetVariable(interp, args[4], Jim_NewStringObj(interp, tail, bytes));
	}
	char buf[50];
	if (rc != RC_OK)
	{
		_assert(!stmt);
		_sprintf(buf, "(%d) ", rc);
		Jim_AppendResult(interp, buf, DataEx::ErrMsg(ctx), nullptr);
		return JIM_ERROR;
	}
	if (stmt)
	{
		if (sqlite3TestMakePointerStr(interp, buf, stmt)) return JIM_ERROR;
		Jim_AppendResult(interp, buf, nullptr);
	}
	return JIM_OK;
}

// Usage: sqlite3_prepare_v2 DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
__device__ static int test_prepare_v2(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 5 && argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB sql bytes tailvar", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	int bytes;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *sql = Jim_String(args[2]);
	if (Jim_GetInt(interp, args[3], &bytes)) return JIM_ERROR;

	Vdbe *stmt = nullptr;
	const char *tail = nullptr;
	RC rc = Prepare::Prepare_v2(ctx, sql, bytes, &stmt, (argc >= 5 ? &tail : nullptr));
	_assert(rc == RC_OK || !stmt);
	Jim_ResetResult(interp);
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	if (tail && argc >= 5)
	{
		if (bytes >= 0)
			bytes = bytes - (int)(tail-sql);
		Jim_SetVariable(interp, args[4], Jim_NewStringObj(interp, tail, bytes));
	}
	char buf[50];
	if (rc != RC_OK)
	{
		_assert(!stmt);
		_sprintf(buf, "(%d) ", rc);
		Jim_AppendResult(interp, buf, DataEx::ErrMsg(ctx), nullptr);
		return JIM_ERROR;
	}
	if (stmt)
	{
		if (sqlite3TestMakePointerStr(interp, buf, stmt)) return JIM_ERROR;
		Jim_AppendResult(interp, buf, nullptr);
	}
	return JIM_OK;
}

// Usage: sqlite3_prepare_tkt3134 DB
//
// Generate a prepared statement for a zero-byte string as a test for ticket #3134.  The string should be preceeded by a zero byte.
__device__ static int test_prepare_tkt3134(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB sql bytes tailvar", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;

	Vdbe *stmt = nullptr;
	static const char sql[] = "\000SELECT 1";
	RC rc = Prepare::Prepare_v2(ctx, &sql[1], 0, &stmt, nullptr);
	_assert(rc == RC_OK || !stmt);
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	char buf[50];
	if (rc != RC_OK)
	{
		_assert(!stmt);
		_sprintf(buf, "(%d) ", rc);
		Jim_AppendResult(interp, buf, DataEx::ErrMsg(ctx), nullptr);
		return JIM_ERROR;
	}
	if (stmt)
	{
		if (sqlite3TestMakePointerStr(interp, buf, stmt)) return JIM_ERROR;
		Jim_AppendResult(interp, buf, nullptr);
	}
	return JIM_OK;
}

// Usage: sqlite3_prepare16 DB sql bytes tailvar
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A STMT handle is returned.
__device__ static int test_prepare16(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_UTF16
	if (argc != 5 && argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB sql bytes ?tailvar?", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	int bytes; // The integer specified as arg 3
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	int sqlLength; // The byte-array length of arg 2
	const void *sql = Jim_GetByteArray(args[2], &sqlLength);
	if (Jim_GetInt(interp, args[3], &bytes)) return JIM_ERROR;

	Vdbe *stmt = nullptr;	
	const void *tail = nullptr;
	RC rc = Prepare::Prepare16(ctx, sql, bytes, &stmt, (argc >= 5 ? &tail : nullptr));
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	if (rc)
		return JIM_ERROR;
	if (argc >= 5)
	{
		sqlLength = (tail ? sqlLength - (int)((uint8 *)tail-(uint8 *)sql) : 0);
		Jim_SetVariable(interp, args[4], Jim_NewByteArrayObj(interp, tail, bytes));
	}
	char buf[50];
	if (stmt)
		if (sqlite3TestMakePointerStr(interp, buf, stmt)) return JIM_ERROR;
	Jim_AppendResult(interp, buf, nullptr);
#endif
	return JIM_OK;
}

// Usage: sqlite3_prepare16_v2 DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A STMT handle is returned.
__device__ static int test_prepare16_v2(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_UTF16
	if (argc != 5 && argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB sql bytes ?tailvar?", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	int bytes; // The integer specified as arg 3
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	int sqlLength; // The byte-array length of arg 2
	const void *sql = Jim_GetByteArray(args[2], &sqlLength);
	if (Jim_GetInt(interp, args[3], &bytes)) return JIM_ERROR;

	Vdbe *stmt = nullptr;
	const void *tail = nullptr;
	RC rc = Prepare::Prepare16_v2(ctx, sql, bytes, &stmt, (argc >= 5 ? &tail : nullptr));
	if (sqlite3TestErrCode(interp, ctx, rc)) return JIM_ERROR;
	if (rc)
		return JIM_ERROR;
	if (argc >= 5)
	{
		sqlLength = (tail ? sqlLength - (int)((uint8 *)tail-(uint8 *)sql) : 0);
		Jim_SetVariable(interp, args[4], Jim_NewByteArrayObj(interp, tail, bytes));
	}
	char buf[50];
	if (stmt)
		if (sqlite3TestMakePointerStr(interp, buf, stmt)) return JIM_ERROR;
	Jim_AppendResult(interp, buf, nullptr);
#endif
	return JIM_OK;
}

// Usage: sqlite3_open filename ?options-list?
__device__ static int test_open(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3 && argc != 2 && argc != 1)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " filename options-list", nullptr);
		return JIM_ERROR;
	}
	const char *filename = (argc > 1 ? Jim_String(args[1]) : nullptr);
	Context *ctx;
	DataEx::Open(filename, &ctx);
	char buf[100];
	if (sqlite3TestMakePointerStr(interp, buf, ctx)) return JIM_ERROR;
	Jim_AppendResult(interp, buf, nullptr);
	return JIM_OK;
}

// Usage: sqlite3_open_v2 FILENAME FLAGS VFS
__constant__ static struct OpenFlag {
	const char *FlagName;
	VSystem::OPEN Flag;
} _flags[] = {
	{ "SQLITE_OPEN_READONLY", VSystem::OPEN::OPEN_READONLY },
	{ "SQLITE_OPEN_READWRITE", VSystem::OPEN::OPEN_READWRITE },
	{ "SQLITE_OPEN_CREATE", VSystem::OPEN::OPEN_CREATE },
	{ "SQLITE_OPEN_DELETEONCLOSE", VSystem::OPEN::OPEN_DELETEONCLOSE },
	{ "SQLITE_OPEN_EXCLUSIVE", VSystem::OPEN::OPEN_EXCLUSIVE },
	{ "SQLITE_OPEN_AUTOPROXY", VSystem::OPEN::OPEN_AUTOPROXY },
	{ "SQLITE_OPEN_MAIN_DB", VSystem::OPEN::OPEN_MAIN_DB },
	{ "SQLITE_OPEN_TEMP_DB", VSystem::OPEN::OPEN_TEMP_DB },
	{ "SQLITE_OPEN_TRANSIENT_DB", VSystem::OPEN::OPEN_TRANSIENT_DB },
	{ "SQLITE_OPEN_MAIN_JOURNAL", VSystem::OPEN::OPEN_MAIN_JOURNAL },
	{ "SQLITE_OPEN_TEMP_JOURNAL", VSystem::OPEN::OPEN_TEMP_JOURNAL },
	{ "SQLITE_OPEN_SUBJOURNAL", VSystem::OPEN::OPEN_SUBJOURNAL },
	{ "SQLITE_OPEN_MASTER_JOURNAL", VSystem::OPEN::OPEN_MASTER_JOURNAL },
	{ "SQLITE_OPEN_NOMUTEX", VSystem::OPEN::OPEN_NOMUTEX },
	{ "SQLITE_OPEN_FULLMUTEX", VSystem::OPEN::OPEN_FULLMUTEX },
	{ "SQLITE_OPEN_SHAREDCACHE", VSystem::OPEN::OPEN_SHAREDCACHE },
	{ "SQLITE_OPEN_PRIVATECACHE", VSystem::OPEN::OPEN_PRIVATECACHE },
	{ "SQLITE_OPEN_WAL", VSystem::OPEN::OPEN_WAL },
	{ "SQLITE_OPEN_URI", VSystem::OPEN::OPEN_URI },
	{ nullptr, (VSystem::OPEN)0 }
};
__device__ static int test_open_v2(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_WrongNumArgs(interp, 1, args, "FILENAME FLAGS VFS");
		return JIM_ERROR;
	}
	const char *filename = Jim_String(args[1]);
	const char *vfs = Jim_String(args[3]);
	if (vfs[0] == 0x00) vfs = nullptr;
	int flagLength;
	Jim_Obj **flags;
	int rc = Jim_ListGetElements(interp, args[2], &flagLength, &flags);
	if (rc != JIM_OK) return rc;
	VSystem::OPEN flags2 = (VSystem::OPEN)0;
	for (int i = 0; i < flagLength; i++)
	{
		int flagId;
		rc = Jim_GetEnumFromStruct(interp, flags[i], (const void **)_flags, sizeof(_flags[0]), &flagId, "flag", 0);
		if (rc != JIM_OK) return rc;
		flags2 |= _flags[flagId].Flag;
	}

	Context *ctx;
	rc = (int)DataEx::Open_v2(filename, &ctx, flags2, vfs);
	char buf[100];
	if (sqlite3TestMakePointerStr(interp, buf, ctx)) return JIM_ERROR;
	Jim_AppendResult(interp, buf, nullptr);
	return JIM_OK;
}

// Usage: sqlite3_open16 filename options
__device__ static int test_open16(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_UTF16
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " filename options-list", nullptr);
		return JIM_ERROR;
	}
	const void *filename = Jim_GetByteArray(args[1], 0);
	Context *ctx;
	DataEx::Open16(filename, &ctx);

	char buf[100];
	if (sqlite3TestMakePointerStr(interp, buf, ctx)) return JIM_ERROR;
	Jim_AppendResult(interp, buf, nullptr);
#endif
	return JIM_OK;
}

// Usage: sqlite3_complete16 <UTF-16 string>
//
// Return 1 if the supplied argument is a complete SQL statement, or zero otherwise.
__device__ static int test_complete16(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#if !defined(OMIT_COMPLETE) && !defined(OMIT_UTF16)
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "<utf-16 sql>");
		return JIM_ERROR;
	}
	char *buf = (char *)Jim_GetByteArray(args[1], 0);
	Jim_SetResultInt(interp, Parse::Complete16(buf));
#endif
	return JIM_OK;
}

// Usage: sqlite3_step STMT
//
// Advance the statement to the next row.
__device__ static int test_step(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	RC rc = stmt->Step();
	//if (rc != RC_DONE && rc != RC_ROW) return JIM_ERROR;
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	return JIM_OK;
}

__device__ static int test_sql(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "STMT");
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	Jim_SetResultString(interp, (char *)Vdbe::Sql(stmt), -1);
	return JIM_OK;
}

// Usage: sqlite3_column_count STMT 
//
// Return the number of columns returned by the sql statement STMT.
__device__ static int test_column_count(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	Jim_SetResultInt(interp, Vdbe::Column_Count(stmt));
	return JIM_OK;
}

// Usage: sqlite3_column_type STMT column
//
// Return the type of the data in column 'column' of the current row.
__device__ static int test_column_type(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int col;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &col)) return JIM_ERROR;

	TYPE tp = Vdbe::Column_Type(stmt, col);
	switch (tp)
	{
	case TYPE_INTEGER: Jim_SetResultString(interp, "INTEGER", -1); break;
	case TYPE_NULL: Jim_SetResultString(interp, "NULL", -1); break;
	case TYPE_FLOAT: Jim_SetResultString(interp, "FLOAT", -1); break;
	case TYPE_TEXT: Jim_SetResultString(interp, "TEXT", -1); break;
	case TYPE_BLOB: Jim_SetResultString(interp, "BLOB", -1); break;
	default: _assert(false);
	}
	return JIM_OK;
}

// Usage: sqlite3_column_int64 STMT column
//
// Return the data in column 'column' of the current row cast as an wide (64-bit) integer.
__device__ static int test_column_int64(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int col;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &col)) return JIM_ERROR;

	int64 val = Vdbe::Column_Int64(stmt, col);
	Jim_SetResultWide(interp, val);
	return JIM_OK;
}

// Usage: sqlite3_column_blob STMT column
__device__ static int test_column_blob(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int col;
	if( getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &col)) return JIM_ERROR;

	int len = Vdbe::Column_Bytes(stmt, col);
	const void *blob = Vdbe::Column_Blob(stmt, col);
	Jim_SetResultByteArray(interp, blob, len);
	return JIM_OK;
}

// Usage: sqlite3_column_double STMT column
//
// Return the data in column 'column' of the current row cast as a double.
__device__ static int test_column_double(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int col;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &col)) return JIM_ERROR;

	double val = Vdbe::Column_Double(stmt, col);
	Jim_SetResult(interp, Jim_NewDoubleObj(interp, val));
	return JIM_OK;
}

// Usage: sqlite3_data_count STMT 
//
// Return the number of columns returned by the sql statement STMT.
__device__ static int test_data_count(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", (args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;

	Jim_SetResultInt(interp, Vdbe::Data_Count(stmt));
	return JIM_OK;
}

// Usage: sqlite3_column_text STMT column
// Usage: sqlite3_column_decltype STMT column
// Usage: sqlite3_column_name STMT column
__device__ static int test_stmt_utf8(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int col;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &col)) return JIM_ERROR;
	const char *(*func)(Vdbe*,int) = (const char *(*)(Vdbe*,int))clientData;
	const char *ret = func(stmt, col);
	if (ret)
		Jim_SetResultString(interp, (char *)ret, -1);
	return JIM_OK;
}

__device__ static int test_global_recover(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_DEPRECATED
	//if (argc != 1)
	//{
	//	Jim_WrongNumArgs(interp, 1, args, "");
	//	return JIM_ERROR;
	//}
	//RC rc = sqlite3_global_recover();
	//Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
#endif
	return JIM_OK;
}

// Usage: sqlite3_column_text STMT column
// Usage: sqlite3_column_decltype STMT column
// Usage: sqlite3_column_name STMT column
__device__ static int test_stmt_utf16(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_UTF16
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int col;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &col)) return JIM_ERROR;

	const void *(*func)(Vdbe*,int) = (const void *(*)(Vdbe*,int))clientData;
	const void *name16 = func(stmt, col);
	if (name16)
	{
		int n = _strlen16(name16);
		Jim_SetResultByteArray(interp, name16, n+2);
	}
#endif
	return JIM_OK;
}

// Usage: sqlite3_column_int STMT column
// Usage: sqlite3_column_bytes STMT column
// Usage: sqlite3_column_bytes16 STMT column
__device__ static int test_stmt_int(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " STMT column", nullptr);
		return JIM_ERROR;
	}
	Vdbe *stmt;
	int col;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &col)) return JIM_ERROR;

	int (*func)(Vdbe*,int) = (int (*)(Vdbe*,int))clientData;
	Jim_SetResultInt(interp, func(stmt, col));
	return JIM_OK;
}

// Usage:  sqlite_set_magic  DB  MAGIC-NUMBER
//
// Set the db->magic value.  This is used to test error recovery logic.
__device__ static int sqlite_set_magic(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB MAGIC", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *type = Jim_String(args[2]);
	if (!_strcmp(type, "SQLITE_MAGIC_OPEN")) ctx->Magic = MAGIC_OPEN;
	else if (!_strcmp(type, "SQLITE_MAGIC_CLOSED")) ctx->Magic = MAGIC_CLOSED;
	else if (!_strcmp(type, "SQLITE_MAGIC_BUSY")) ctx->Magic = MAGIC_BUSY;
	else if (!_strcmp(type, "SQLITE_MAGIC_ERROR")) ctx->Magic = MAGIC_ERROR;
	else if (Jim_GetInt(interp, args[2], (int *)&ctx->Magic)) return JIM_ERROR;
	return JIM_OK;
}

// Usage:  sqlite3_interrupt  DB 
//
// Trigger an interrupt on DB
__device__ static int test_interrupt(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	DataEx::Interrupt(ctx);
	return JIM_OK;
}

__device__ static uint8 *_stack_baseline = nullptr;

// Fill the stack with a known bitpattern.
__device__ static void prepStack()
{
	int i;
	uint32 bigBuf[65536];
	for (i = 0; i < _lengthof(bigBuf); i++) bigBuf[i] = 0xdeadbeef;
	_stack_baseline = (uint8 *)&bigBuf[65536];
}

// Get the current stack depth.  Used for debugging only.
__device__ uint64 sqlite3StackDepth()
{
	uint8 x;
	return (uint64)(_stack_baseline - &x);
}

// Usage:  sqlite3_stack_used DB SQL
//
// Try to measure the amount of stack space used by a call to sqlite3_exec
__device__ static int test_stack_used(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB SQL", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	prepStack();
	DataEx::Exec(ctx, Jim_String(args[2]), 0, 0, 0);
	int i;
	for (i = 65535; i >= 0 && ((uint32 *)_stack_baseline)[-i] == 0xdeadbeef; i--) { }
	Jim_SetResultInt(interp, i*4);
	return JIM_OK;
}

// Usage: sqlite_delete_function DB function-name
//
// Delete the user function 'function-name' from database handle DB. It is assumed that the user function was created as UTF8, any number of
// arguments (the way the TCL interface does it).
__device__ static int delete_function(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB function-name", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::CreateFunction(ctx, Jim_String(args[2]), -1, TEXTENCODE_UTF8, 0, 0, 0, 0);
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	return JIM_OK;
}

// Usage: sqlite_delete_collation DB collation-name
//
// Delete the collation sequence 'collation-name' from database handle  DB. It is assumed that the collation sequence was created as UTF8 (the 
// way the TCL interface does it).
__device__ static int delete_collation(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB function-name", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::CreateCollation(ctx, Jim_String(args[2]), TEXTENCODE_UTF8, nullptr, nullptr);
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	return JIM_OK;
}

// Usage: sqlite3_get_autocommit DB
//
// Return true if the database DB is currently in auto-commit mode. Return false if not.
__device__ static int get_autocommit(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	char buf[30];
	_sprintf(buf, "%d", ctx->AutoCommit);
	Jim_AppendResult(interp, buf, nullptr);
	return JIM_OK;
}

// Usage: sqlite3_busy_timeout DB MS
//
// Set the busy timeout.  This is more easily done using the timeout method of the TCL interface.  But we need a way to test the case
// where it returns SQLITE_MISUSE.
__device__ static int test_busy_timeout(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	int ms;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &ms)) return JIM_ERROR;
	RC rc = DataEx::BusyTimeout(ctx, ms);
	Jim_AppendResult(interp, sqlite3TestErrorName(rc), nullptr);
	return JIM_OK;
}

// Usage:  tcl_variable_type VARIABLENAME
//
// Return the name of the internal representation for the value of the given variable.
__device__ static int tcl_variable_type(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "VARIABLE");
		return JIM_ERROR;
	}
	Jim_Obj *var = Jim_GetVariable(interp, args[1], JIM_ERRMSG);
	if (!var) return JIM_ERROR;
	if (var->typePtr)
		Jim_SetResultString(interp, var->typePtr->name, -1);
	return JIM_OK;
}

// Usage:  sqlite3_release_memory ?N?
//
// Attempt to release memory currently held but not actually required. The integer N is the number of bytes we are trying to release.  The 
// return value is the amount of memory actually released.
__device__ static int test_release_memory(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#if defined(ENABLE_MEMORY_MANAGEMENT) && !defined(OMIT_DISKIO)
	if (argc != 1 && argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "?N?");
		return JIM_ERROR;
	}
	int N;
	if (argc == 2)
	{
		if (Jim_GetInt(interp, args[1], &N)) return JIM_ERROR;
	}
	else
		N = -1;
	int amt = sqlite3_release_memory(N);
	Jim_SetResultInt(interp, amt);
#endif
	return JIM_OK;
}

// Usage:  sqlite3_db_release_memory DB
//
// Attempt to release memory currently held by database DB.  Return the result code (which in the current implementation is always zero).
__device__ static int test_db_release_memory(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	int rc = (int)DataEx::CtxReleaseMemory(ctx);
	Jim_SetResultInt(interp, rc);
	return JIM_OK;
}

// Usage:  sqlite3_db_filename DB DBNAME
//
// Return the name of a file associated with a database.
__device__ static int test_db_filename(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB DBNAME");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *dbName = Jim_String(args[2]);
	Jim_AppendResult(interp, DataEx::CtxFilename(ctx, dbName), nullptr);
	return JIM_OK;
}

// Usage:  sqlite3_db_readonly DB DBNAME
//
// Return 1 or 0 if DBNAME is readonly or not.  Return -1 if DBNAME does not exist.
__device__ static int test_db_readonly(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB DBNAME");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *dbName = Jim_String(args[2]);
	Jim_SetResultInt(interp, DataEx::CtxReadonly(ctx, dbName));
	return JIM_OK;
}

// Usage:  sqlite3_soft_heap_limit ?N?
//
// Query or set the soft heap limit for the current thread.  The limit is only changed if the N is present.  The previous limit
// is returned.
__device__ static int test_soft_heap_limit(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 1 && argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "?N?");
		return JIM_ERROR;
	}
	int64 N = -1;
	if (argc == 2)
		if (Jim_GetWide(interp, args[1], &N)) return JIM_ERROR;
	extern __device__ int64 __alloc_softheaplimit64(int64 size);
	int64 amt = __alloc_softheaplimit64(N);
	Jim_SetResultWide(interp, amt);
	return JIM_OK;
}

// Usage:   sqlite3_thread_cleanup
//
// Call the sqlite3_thread_cleanup API.
__device__ static int test_thread_cleanup(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
#ifndef OMIT_DEPRECATED
	//sqlite3_thread_cleanup();
#endif
	return JIM_OK;
}

// Usage:   sqlite3_pager_refcounts  DB
//
// Return a list of numbers which are the PagerRefcount for all pagers on each database connection.
__device__ static int test_pager_refcounts(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	Jim_Obj *result = Jim_NewObj(interp);
	for (int i = 0; i < ctx->DBs.length; i++)
	{
		int v;
		if (!ctx->DBs[i].Bt)
			v = -1;
		else
		{
			_mutex_enter(ctx->Mutex);
			int *a = ctx->DBs[i].Bt->get_Pager()->get_Stats();
			v = a[0];
			_mutex_leave(ctx->Mutex);
		}
		Jim_ListAppendElement(nullptr, result, Jim_NewIntObj(interp, v));
	}
	Jim_SetResult(interp, result);
	return JIM_OK;
}


// tclcmd:   working_64bit_int
//
// Some TCL builds (ex: cygwin) do not support 64-bit integers.  This leads to a number of test failures.  The present command checks the
// TCL build to see whether or not it supports 64-bit integers.  It returns TRUE if it does and FALSE if not.
//
// This command is used to warn users that their TCL build is defective and that the errors they are seeing in the test scripts might be
// a result of their defective TCL rather than problems in SQLite.
__device__ static int working_64bit_int(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	Jim_Obj *testObj = Jim_NewWideObj(interp, 1000000*(int64)1234567890);
	bool working = !_strcmp(Jim_String(testObj), "1234567890000000");
	Jim_DecrRefCount(interp, testObj);
	Jim_SetResultBool(interp, working);
	return JIM_OK;
}

// tclcmd:   vfs_unlink_test
//
// This TCL command unregisters the primary VFS and then registers it back again.  This is used to test the ability to register a
// VFS when none are previously registered, and the ability to unregister the only available VFS.  Ticket #2738
__device__ static int vfs_unlink_test(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	VSystem one, two;

	VSystem::UnregisterVfs(nullptr); // Unregister of NULL is harmless
	one.Name = "__one";
	two.Name = "__two";

	// Calling sqlite3_vfs_register with 2nd argument of 0 does not change the default VFS
	VSystem *main = VSystem::FindVfs(nullptr);
	VSystem::RegisterVfs(&one, false);
	_assert(!main || main == VSystem::FindVfs(nullptr));
	VSystem::RegisterVfs(&two, false);
	_assert(!main || main == VSystem::FindVfs(nullptr));

	// We can find a VFS by its name
	_assert(VSystem::FindVfs("__one") == &one);
	_assert(VSystem::FindVfs("__two") == &two);

	// Calling sqlite_vfs_register with non-zero second parameter changes the default VFS, even if the 1st parameter is an existig VFS that is previously registered as the non-default.
	VSystem::RegisterVfs(&one, true);
	_assert(VSystem::FindVfs("__one") == &one);
	_assert(VSystem::FindVfs("__two") == &two);
	_assert(VSystem::FindVfs(nullptr) == &one);
	VSystem::RegisterVfs(&two, true);
	_assert(VSystem::FindVfs("__one") == &one);
	_assert(VSystem::FindVfs("__two") == &two);
	_assert(VSystem::FindVfs(nullptr) == &two);
	if (main)
	{
		VSystem::RegisterVfs(main, true);
		_assert(VSystem::FindVfs("__one") == &one);
		_assert(VSystem::FindVfs("__two") == &two);
		_assert(VSystem::FindVfs(nullptr) == main);
	}

	// Unlink the default VFS.  Repeat until there are no more VFSes registered.
	int i;
	VSystem *vfs[20];
	for (i = 0; i < _lengthof(vfs); i++)
	{
		vfs[i] = VSystem::FindVfs(nullptr);
		if (vfs[i])
		{
			_assert(vfs[i] == VSystem::FindVfs(vfs[i]->Name));
			VSystem::UnregisterVfs(vfs[i]);
			_assert(!VSystem::FindVfs(vfs[i]->Name));
		}
	}
	_assert(!VSystem::FindVfs(nullptr));

	// Register the main VFS as non-default (will be made default, since it'll be the only one in existence).
	VSystem::RegisterVfs(main, false);
	_assert(VSystem::FindVfs(nullptr) == main);

	// Un-register the main VFS again to restore an empty VFS list
	VSystem::UnregisterVfs(main);
	_assert(!VSystem::FindVfs(nullptr));

	// Relink all VFSes in reverse order.
	for (i = _lengthof(vfs)-1; i >= 0; i--)
	{
		if (vfs[i])
		{
			VSystem::RegisterVfs(vfs[i], true);
			_assert(vfs[i] == VSystem::FindVfs(nullptr));
			_assert(vfs[i] == VSystem::FindVfs(vfs[i]->Name));
		}
	}

	// Unregister out sample VFSes.
	VSystem::UnregisterVfs(&one);
	VSystem::UnregisterVfs(&two);

	// Unregistering a VFS that is not currently registered is harmless
	VSystem::UnregisterVfs(&one);
	VSystem::UnregisterVfs(&two);
	_assert(!VSystem::FindVfs("__one"));
	_assert(!VSystem::FindVfs("__two"));

	// We should be left with the original default VFS back as the original
	_assert(VSystem::FindVfs(nullptr) == main);

	return JIM_OK;
}

// tclcmd:   vfs_initfail_test
//
// This TCL command attempts to vfs_find and vfs_register when the sqlite3_initialize() interface is failing.  All calls should fail.
__device__ static int vfs_initfail_test(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	VSystem one;
	one.Name = "__one";

	if (VSystem::FindVfs(nullptr)) return JIM_ERROR;
	VSystem::RegisterVfs(&one, false);
	if (VSystem::FindVfs(nullptr)) return JIM_ERROR;
	VSystem::RegisterVfs(&one, true);
	if (VSystem::FindVfs(nullptr)) return JIM_ERROR;
	return JIM_OK;
}


// Saved VFSes
__device__ static VSystem *_vfs[20];
__device__ static int _vfsLength = 0;

// tclcmd:   vfs_unregister_all
//
// Unregister all VFSes.
__device__ static int vfs_unregister_all(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	int i;
	for (i = 0; i < _lengthof(_vfs); i++)
	{
		_vfs[i] = VSystem::FindVfs(nullptr);
		if (!_vfs[i]) break;
		VSystem::UnregisterVfs(_vfs[i]);
	}
	_vfsLength = i;
	return JIM_OK;
}

// tclcmd:   vfs_reregister_all
//
// Restore all VFSes that were removed using vfs_unregister_all
__device__ static int vfs_reregister_all(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	for (int i = 0; i < _vfsLength; i++)
		VSystem::RegisterVfs(_vfs[i], i == 0);
	return JIM_OK;
}

// tclcmd:   file_control_test DB
//
// This TCL command runs the sqlite3_file_control interface and verifies correct operation of the same.
__device__ static int file_control_test(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	int argId = 0;
	RC rc = DataEx::FileControl(ctx, nullptr, (VFile::FCNTL)0, &argId);
	_assert(rc == RC_NOTFOUND);
	rc = DataEx::FileControl(ctx, "notadatabase", VFile::FCNTL_LOCKSTATE, &argId);
	_assert(rc == RC_ERROR);
	rc = DataEx::FileControl(ctx, "main", (VFile::FCNTL)-1, &argId);
	_assert(rc == RC_NOTFOUND);
	rc = DataEx::FileControl(ctx, "temp", (VFile::FCNTL)-1, &argId);
	_assert(rc == RC_NOTFOUND || rc == RC_ERROR);
	return JIM_OK;
}

// tclcmd:   file_control_lasterrno_test DB
//
// This TCL command runs the sqlite3_file_control interface and verifies correct operation of the SQLITE_LAST_ERRNO verb.
__device__ static int file_control_lasterrno_test(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	int argId = 0;
	RC rc = DataEx::FileControl(ctx, nullptr, VFile::FCNTL_LAST_ERRNO, &argId);
	if (rc)
	{ 
		Jim_SetResultInt(interp, rc); 
		return JIM_ERROR; 
	}
	if (argId != 0)
	{
		char b[50]; _itoa(argId, b);
		Jim_AppendResult(interp, "Unexpected non-zero errno: ", b, " ", nullptr);
		return JIM_ERROR;
	}
	return JIM_OK;  
}

// tclcmd:   file_control_chunksize_test DB DBNAME SIZE
//
// This TCL command runs the sqlite3_file_control interface and verifies correct operation of the SQLITE_GET_LOCKPROXYFILE and
// SQLITE_SET_LOCKPROXYFILE verbs.
__device__ static int file_control_chunksize_test(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB DBNAME SIZE");
		return JIM_ERROR;
	}
	Context *ctx;
	int size; // New chunk size
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx) || Jim_GetInt(interp, args[3], &size)) return JIM_ERROR;
	const char *dbName = Jim_String(args[2]); // Db name ("main", "temp" etc.)
	if (dbName[0] == '\0') dbName = nullptr;
	RC rc = DataEx::FileControl(ctx, dbName, VFile::FCNTL_CHUNK_SIZE, (void *)&size);
	if (rc)
	{
		Jim_SetResultString(interp, (char *)sqlite3TestErrorName(rc), -1);
		return JIM_ERROR;
	}
	return JIM_OK;
}

// tclcmd:   file_control_sizehint_test DB DBNAME SIZE
//
// This TCL command runs the sqlite3_file_control interface with SQLITE_FCNTL_SIZE_HINT
__device__ static int file_control_sizehint_test(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB DBNAME SIZE");
		return JIM_ERROR;
	}
	int64 size; // Hinted size
	Context *ctx; // Database handle
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx) || Jim_GetWide(interp, args[3], &size)) return JIM_ERROR;
	const char *dbName = Jim_String(args[2]); // Db name ("main", "temp" etc.)
	if (dbName[0] == '\0') dbName = nullptr;
	RC rc = DataEx::FileControl(ctx, dbName, VFile::FCNTL_SIZE_HINT, (void *)&size);
	if (rc)
	{
		Jim_SetResultString(interp, (char *)sqlite3TestErrorName(rc), -1);
		return JIM_ERROR;
	}
	return JIM_OK;
}

// tclcmd:   file_control_lockproxy_test DB PWD
//
// This TCL command runs the sqlite3_file_control interface and verifies correct operation of the SQLITE_GET_LOCKPROXYFILE and
// SQLITE_SET_LOCKPROXYFILE verbs.
__device__ static int file_control_lockproxy_test(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB PWD", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;

#if !defined(ENABLE_LOCKING_STYLE)
#if defined(__APPLE__)
# define ENABLE_LOCKING_STYLE 1
#else
# define ENABLE_LOCKING_STYLE 0
#endif
#endif
#if ENABLE_LOCKING_STYLE && defined(__APPLE__)
	{
		int pwdLength;
		const char *pwd = Jim_GetString(interp, args[2], &pwdLength);
		char proxyPath[400];
		if (sizeof(proxyPath) < pwdLength+20)
		{
			Jim_AppendResult(interp, "PWD too big", nullptr);
			return JIM_ERROR;
		}
		_sprintf(proxyPath, "%s/test.proxy", pwd);
		int rc = (int)DataEx::FileControl(ctx, nullptr, VFile::FCNTL_SET_LOCKPROXYFILE, proxyPath);
		if (rc)
		{
			Jim_SetResultInt(interp, rc); 
			return JIM_ERROR;
		}
		char *testPath;
		rc = (int)DataEx::FileControl(ctx, nullptr, VFile::FCNTL_GET_LOCKPROXYFILE, &testPath);
		if (_strncmp(proxyPath, testPath, 11))
		{
			Jim_AppendResult(interp, "Lock proxy file did not match the previously assigned value", nullptr);
			return JIM_ERROR;
		}
		if (rc)
		{
			Jim_SetResultInt(interp, rc);
			return JIM_ERROR;
		}
		rc = (int)DataEx::FileControl(ctx, nullptr, VFile::FCNTL_SET_LOCKPROXYFILE, proxyPath);
		if (rc)
		{
			Jim_SetResultInt(interp, rc);
			return JIM_ERROR;
		}
	}
#endif
	return JIM_OK;  
}

// tclcmd:   file_control_win32_av_retry DB  NRETRY  DELAY
//
// This TCL command runs the sqlite3_file_control interface with the SQLITE_FCNTL_WIN32_AV_RETRY opcode.
__device__ static int file_control_win32_av_retry(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB NRETRY DELAY", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	int a[2];
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &a[0])) return JIM_ERROR;
	if (Jim_GetInt(interp, args[3], &a[1])) return JIM_ERROR;
	RC rc = DataEx::FileControl(ctx, nullptr, VFile::FCNTL_WIN32_AV_RETRY, (void *)a);
	char z[100];
	__snprintf(z, sizeof(z), "%d %d %d", rc, a[0], a[1]);
	Jim_AppendResult(interp, z, nullptr);
	return JIM_OK;  
}

// tclcmd:   file_control_persist_wal DB PERSIST-FLAG
//
// This TCL command runs the sqlite3_file_control interface with the SQLITE_FCNTL_PERSIST_WAL opcode.
__device__ static int file_control_persist_wal(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB FLAG", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	bool persist;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	if (Jim_GetBoolean(interp, args[2], &persist)) return JIM_ERROR;
	RC rc = DataEx::FileControl(ctx, nullptr, VFile::FCNTL_PERSIST_WAL, (void *)&persist);
	char z[100];
	__snprintf(z, sizeof(z), "%d %d", rc, persist);
	Jim_AppendResult(interp, z, nullptr);
	return JIM_OK;  
}

// tclcmd:   file_control_powersafe_overwrite DB PSOW-FLAG
//
// This TCL command runs the sqlite3_file_control interface with the SQLITE_FCNTL_POWERSAFE_OVERWRITE opcode.
__device__ static int file_control_powersafe_overwrite(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB FLAG", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	int b;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[2], &b)) return JIM_ERROR;
	RC rc = DataEx::FileControl(ctx, nullptr, VFile::FCNTL_POWERSAFE_OVERWRITE, (void *)&b);
	char z[100];
	__snprintf(z, sizeof(z), "%d %d", rc, b);
	Jim_AppendResult(interp, z, nullptr);
	return JIM_OK;  
}

// tclcmd:   file_control_vfsname DB ?AUXDB?
//
// Return a string that describes the stack of VFSes.
__device__ static int file_control_vfsname(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2 && argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB ?AUXDB?", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *dbName = (argc == 3 ? Jim_String(args[2]) : "main");
	char *vfsName = nullptr;
	DataEx::FileControl(ctx, dbName, VFile::FCNTL_VFSNAME, (void *)&vfsName);
	Jim_AppendResult(interp, vfsName, nullptr);
	_free(vfsName);
	return JIM_OK;  
}

// tclcmd:   file_control_tempfilename DB ?AUXDB?
//
// Return a string that is a temporary filename
__device__ static int file_control_tempfilename(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2 && argc != 3)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB ?AUXDB?", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *dbName = (argc == 3 ? Jim_String(args[2]) : "main");
	char *tName = nullptr;
	DataEx::FileControl(ctx, dbName, VFile::FCNTL_TEMPFILENAME, (void *)&tName);
	Jim_AppendResult(interp, tName, nullptr);
	_free(tName);
	return JIM_OK;  
}

// tclcmd:   sqlite3_vfs_list
//
//   Return a tcl list containing the names of all registered vfs's.
__device__ static int vfs_list(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 1)
	{
		Jim_WrongNumArgs(interp, 1, args, "");
		return JIM_ERROR;
	}
	Jim_Obj *ret = Jim_NewObj(interp);
	for (VSystem *vfs = VSystem::FindVfs(nullptr); vfs; vfs = vfs->Next)
		Jim_ListAppendElement(interp, ret, Jim_NewStringObj(interp, vfs->Name, -1));
	Jim_SetResult(interp, ret);
	return JIM_OK;  
}


// tclcmd:   sqlite3_limit DB ID VALUE
//
// This TCL command runs the sqlite3_limit interface and verifies correct operation of the same.
__constant__ static const struct {
	char *Name;
	LIMIT Id;
} _ids[] = {
	{ "SQLITE_LIMIT_LENGTH",              LIMIT_LENGTH				},
	{ "SQLITE_LIMIT_SQL_LENGTH",          LIMIT_SQL_LENGTH			},
	{ "SQLITE_LIMIT_COLUMN",              LIMIT_COLUMN				},
	{ "SQLITE_LIMIT_EXPR_DEPTH",          LIMIT_EXPR_DEPTH			},
	{ "SQLITE_LIMIT_COMPOUND_SELECT",     LIMIT_COMPOUND_SELECT		},
	{ "SQLITE_LIMIT_VDBE_OP",             LIMIT_VDBE_OP				},
	{ "SQLITE_LIMIT_FUNCTION_ARG",        LIMIT_FUNCTION_ARG		},
	{ "SQLITE_LIMIT_ATTACHED",            LIMIT_ATTACHED			},
	{ "SQLITE_LIMIT_LIKE_PATTERN_LENGTH", LIMIT_LIKE_PATTERN_LENGTH },
	{ "SQLITE_LIMIT_VARIABLE_NUMBER",     LIMIT_VARIABLE_NUMBER     },
	{ "SQLITE_LIMIT_TRIGGER_DEPTH",       LIMIT_TRIGGER_DEPTH       },

	// Out of range test cases
	{ "SQLITE_LIMIT_TOOSMALL",            (LIMIT)-1,                },
	{ "SQLITE_LIMIT_TOOBIG",              (LIMIT)((int)LIMIT_TRIGGER_DEPTH+1) },
};
__device__ static int test_limit(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_AppendResult(interp, "wrong # args: should be \"", Jim_String(args[0]), " DB ID VALUE", nullptr);
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *idName = Jim_String(args[2]);
	int i;
	LIMIT id;
	for (i = 0; i < _lengthof(_ids); i++)
	{
		if (!_strcmp(idName, _ids[i].Name))
		{
			id = _ids[i].Id;
			break;
		}
	}
	if (i >= _lengthof(_ids))
	{
		Jim_AppendResult(interp, "unknown limit type: ", idName, nullptr);
		return JIM_ERROR;
	}
	int val;
	if (Jim_GetInt(interp, args[3], &val)) return JIM_ERROR;
	int rc = DataEx::Limit(ctx, id, val);
	Jim_SetResultInt(interp, rc);
	return JIM_OK;  
}

// tclcmd:  save_prng_state
//
// Save the state of the pseudo-random number generator. At the same time, verify that sqlite3_test_control works even when
// called with an out-of-range opcode.
__device__ static int save_prng_state(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	RC rc = DataEx::TestControl((DataEx::TESTCTRL)9999);
	_assert(rc == RC_OK);
	rc = DataEx::TestControl((DataEx::TESTCTRL)-1);
	_assert(rc == RC_OK);
	DataEx::TestControl(DataEx::TESTCTRL_PRNG_SAVE);
	return JIM_OK;
}
// tclcmd:  restore_prng_state
__device__ static int restore_prng_state(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	DataEx::TestControl(DataEx::TESTCTRL_PRNG_RESTORE);
	return JIM_OK;
}
// tclcmd:  reset_prng_state
__device__ static int reset_prng_state(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	DataEx::TestControl(DataEx::TESTCTRL_PRNG_RESET);
	return JIM_OK;
}

// tclcmd:  pcache_stats
extern "C" __device__ void PCache1_testStats(uint *current, uint *max, uint *min, uint *recyclables);
__device__ static int test_pcache_stats(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	uint min;
	uint max;
	uint current;
	uint recyclables;
	PCache1_testStats(&current, &max, &min, &recyclables);
	Jim_Obj *ret = Jim_NewObj(interp);
	Jim_ListAppendElement(interp, ret, Jim_NewStringObj(interp, "current", -1));
	Jim_ListAppendElement(interp, ret, Jim_NewIntObj(interp, current));
	Jim_ListAppendElement(interp, ret, Jim_NewStringObj(interp, "max", -1));
	Jim_ListAppendElement(interp, ret, Jim_NewIntObj(interp, max));
	Jim_ListAppendElement(interp, ret, Jim_NewStringObj(interp, "min", -1));
	Jim_ListAppendElement(interp, ret, Jim_NewIntObj(interp, min));
	Jim_ListAppendElement(interp, ret, Jim_NewStringObj(interp, "recyclable", -1));
	Jim_ListAppendElement(interp, ret, Jim_NewIntObj(interp, recyclables));
	Jim_SetResult(interp, ret);
	return JIM_OK;
}

#ifdef ENABLE_UNLOCK_NOTIFY
__device__ static void test_unlock_notify_cb(void **args, int argLength)
{
	for (int i=0; i < argLength; i++)
		Jim_EvalEx((Jim_Interp *)args[i], "unlock_notify", -1, JIM_EVAL_GLOBAL);
}

// tclcmd:  sqlite3_unlock_notify db
__device__ static int test_unlock_notify(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	RC rc = DataEx::UnlockNotify(ctx, test_unlock_notify_cb, (void *)interp);
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	return JIM_OK;
}
#endif

// tclcmd:  sqlite3_wal_checkpoint db ?NAME?
__device__ static int test_wal_checkpoint(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 3 && argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB ?NAME?");
		return JIM_ERROR;
	}
	Context *ctx;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	const char *dbName = (argc == 3 ? Jim_String(args[2]) : nullptr);
	RC rc = DataEx::WalCheckpoint(ctx, dbName);
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	return JIM_OK;
}

// tclcmd:  sqlite3_wal_checkpoint_v2 db MODE ?NAME?
//
// This command calls the wal_checkpoint_v2() function with the specified mode argument (passive, full or restart). If present, the database name
// NAME is passed as the second argument to wal_checkpoint_v2(). If it the NAME argument is not present, a NULL pointer is passed instead.
//
// If wal_checkpoint_v2() returns any value other than SQLITE_BUSY or SQLITE_OK, then this command returns JIM_ERROR. The Tcl result is set
// to the error message obtained from sqlite3_errmsg().
//
// Otherwise, this command returns a list of three integers. The first integer is 1 if SQLITE_BUSY was returned, or 0 otherwise. The following two integers
// are the values returned via the output paramaters by wal_checkpoint_v2() - the number of frames in the log and the number of frames in the log
// that have been checkpointed.
__device__ static int test_wal_checkpoint_v2(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	const char *_modes[] = { "passive", "full", "restart", 0 };
	_assert(IPager::CHECKPOINT_PASSIVE == 0);
	_assert(IPager::CHECKPOINT_FULL == 1);
	_assert(IPager::CHECKPOINT_RESTART == 2);

	if (argc != 3 && argc != 4)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB MODE ?NAME?");
		return JIM_ERROR;
	}
	const char *dbName = (argc == 4 ? Jim_String(args[3]) : nullptr);
	Context *ctx;
	IPager::CHECKPOINT mode;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx) || Jim_GetEnum(interp, args[2], (const char **)_modes, (int *)&mode, "mode", 0)) return JIM_ERROR;

	int logs = -555;
	int ckpts = -555;
	RC rc = DataEx::WalCheckpoint_v2(ctx, dbName, mode, &logs, &ckpts);
	if (rc != RC_OK && rc != RC_BUSY)
	{
		Jim_SetResultString(interp, (char *)DataEx::ErrMsg(ctx), -1);
		return JIM_ERROR;
	}

	Jim_Obj *ret = Jim_NewObj(interp);
	Jim_ListAppendElement(interp, ret, Jim_NewIntObj(interp, rc == RC_BUSY ? 1 : 0));
	Jim_ListAppendElement(interp, ret, Jim_NewIntObj(interp, logs));
	Jim_ListAppendElement(interp, ret, Jim_NewIntObj(interp, ckpts));
	Jim_SetResult(interp, ret);
	return JIM_OK;
}

// tclcmd:  test_sqlite3_log ?SCRIPT?
__device__ static struct LogCallback
{
	Jim_Interp *Interp;
	Jim_Obj *Obj;
} _logcallback = { nullptr, nullptr };
__device__ static void xLogcallback(void *unused, int err, char *msg)
{
	Jim_Interp *interp = _logcallback.Interp;
	Jim_Obj *new_ = Jim_DuplicateObj(interp, _logcallback.Obj);

	Jim_IncrRefCount(new_);
	Jim_ListAppendElement(nullptr, new_, Jim_NewStringObj(interp, sqlite3TestErrorName(err), -1));
	Jim_ListAppendElement(nullptr, new_, Jim_NewStringObj(interp, msg, -1));
	Jim_EvalObj(interp, new_);
	Jim_DecrRefCount(interp, new_);
}
__device__ static int test_sqlite3_log(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc > 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "SCRIPT");
		return JIM_ERROR;
	}
	if (_logcallback.Obj)
	{
		Jim_DecrRefCount(interp, _logcallback.Obj);
		_logcallback.Obj = nullptr;
		_logcallback.Interp = nullptr;
		SysEx::Config(SysEx::CONFIG_LOG, 0, 0);
	}
	if (argc > 1)
	{
		_logcallback.Obj = args[1];
		Jim_IncrRefCount(_logcallback.Obj);
		_logcallback.Interp = interp;
		SysEx::Config(SysEx::CONFIG_LOG, xLogcallback, 0);
	}
	return JIM_OK;
}

//     tcl_objproc COMMANDNAME ARGS...
//
// Run a TCL command using its objProc interface.  Throw an error if the command has no objProc interface.
__device__ static int runAsObjProc(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc < 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "COMMAND ...");
		return JIM_ERROR;
	}
	Jim_CmdInfo cmdInfo;
	if (!Jim_GetCommandInfo(interp, args[1], &cmdInfo))
	{
		Jim_AppendResult(interp, "command not found: ", Jim_String(args[1]), nullptr);
		return JIM_ERROR;
	}
	if (!cmdInfo.objProc)
	{
		Jim_AppendResult(interp, "command has no objProc: ", Jim_String(args[1]), nullptr);
		return JIM_ERROR;
	}
	return cmdInfo.objProc(cmdInfo.objClientData, interp, argc-1, args+1);
}

#ifndef OMIT_EXPLAIN
// WARNING: The following function, printExplainQueryPlan() is an exact copy of example code from eqp.in (eqp.html). If this code is modified,
// then the documentation copy needs to be modified as well.
//
//
// Argument pStmt is a prepared SQL statement. This function compiles an EXPLAIN QUERY PLAN command to report on the prepared statement,
// and prints the report to stdout using printf().
__device__ RC printExplainQueryPlan(Vdbe *stmt)
{
	const char *sql = Vdbe::Sql(stmt); // Input SQL
	if (!sql) return RC_ERROR;
	char *explain = _mprintf("EXPLAIN QUERY PLAN %s", sql);
	if (!explain) return RC_NOMEM;
	Vdbe *explainStmt; // Compiled EXPLAIN QUERY PLAN command
	RC rc = Prepare::Prepare_v2(Vdbe::Stmt_Ctx(stmt), explain, -1, &explainStmt, 0);
	_free(explain);
	if (rc != RC_OK) return rc;
	while (explainStmt->Step() != RC_ROW)
	{
		int selectid = Vdbe::Column_Int(explainStmt, 0);
		int orderid = Vdbe::Column_Int(explainStmt, 1);
		int fromid = Vdbe::Column_Int(explainStmt, 2);
		const char *detail = (const char *)Vdbe::Column_Text(explainStmt, 3);
		_printf("%d %d %d %s\n", selectid, orderid, fromid, detail);
	}
	return Vdbe::Finalize(explainStmt);
}

__device__ static int test_print_eqp(ClientData clientData,Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "STMT");
		return JIM_ERROR;
	}
	Vdbe *stmt;
	if (getStmtPointer(interp, Jim_String(args[1]), &stmt)) return JIM_ERROR;
	RC rc = printExplainQueryPlan(stmt);
	// This is needed on Windows so that a test case using this function can open a read pipe and get the output of printExplainQueryPlan() immediately.
	_fflush(_stdout);
	Jim_SetResultString(interp, (char *)t1ErrorName(rc), -1);
	return JIM_OK;
}
#endif

// sqlite3_test_control VERB ARGS...
__constant__ struct Verb
{
	const char *Name;
	int Id;
} _verbs[] = {
	{ "SQLITE_TESTCTRL_LOCALTIME_FAULT", DataEx::TESTCTRL_LOCALTIME_FAULT }, 
};
__device__ static int test_test_control(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc < 2)
	{
		Jim_WrongNumArgs(interp, 1, args, "VERB ARGS...");
		return JIM_ERROR;
	}
	int verbId;
	int rc = Jim_GetEnumFromStruct(interp, args[1], (const void **)_verbs, sizeof(_verbs[0]), &verbId, "VERB", 0);
	if (rc != JIM_OK) return rc;
	int flagId = _verbs[verbId].Id;
	switch (flagId)
	{
	case DataEx::TESTCTRL_LOCALTIME_FAULT: {
		if (argc != 3)
		{
			Jim_WrongNumArgs(interp, 2, args, "ONOFF");
			return JIM_ERROR;
		}
		bool val;
		if (Jim_GetBoolean(interp, args[2], &val)) return JIM_ERROR;
		DataEx::TestControl(DataEx::TESTCTRL_LOCALTIME_FAULT, val);
		break; }
	}
	Jim_ResetResult(interp);
	return JIM_OK;
}

#if OS_WIN
#include <windows.h>
#include <process.h>

// Information passed from the main thread into the windows file locker background thread.
struct win32FileLocker
{
	char *evName;       // Name of event to signal thread startup
	HANDLE h;           // Handle of the file to be locked
	int delay1;         // Delay before locking
	int delay2;         // Delay before unlocking
	int ok;             // Finished ok
	int err;            // True if an error occurs
};

// The background thread that does file locking.
__device__ static void win32_file_locker(void *appData)
{
	struct win32FileLocker *p = (struct win32FileLocker *)appData;
	if (p->evName)
	{
		HANDLE ev = OpenEvent(EVENT_MODIFY_STATE, FALSE, p->evName);
		if (ev)
		{
			SetEvent(ev);
			CloseHandle(ev);
		}
	}
	if (p->delay1) Sleep(p->delay1);
	if (LockFile(p->h, 0, 0, 100000000, 0))
	{
		Sleep(p->delay2);
		UnlockFile(p->h, 0, 0, 100000000, 0);
		p->ok = 1;
	}
	else
		p->err = 1;
	CloseHandle(p->h);
	p->h = 0;
	p->delay1 = 0;
	p->delay2 = 0;
}

//      lock_win32_file FILENAME DELAY1 DELAY2
//
// Get an exclusive manditory lock on file for DELAY2 milliseconds. Wait DELAY1 milliseconds before acquiring the lock.
__constant__ static struct win32FileLocker _x = { "win32_file_lock", 0, 0, 0, 0, 0 };
__device__ static int win32_file_lock(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4 && argc != 1)
	{
		Jim_WrongNumArgs(interp, 1, args, "FILENAME DELAY1 DELAY2");
		return JIM_ERROR;
	}
	char buf[200];
	if (argc == 1)
	{
		__snprintf(buf, sizeof(buf), "%d %d %d %d %d", _x.ok, _x.err, _x.delay1, _x.delay2, _x.h);
		Jim_AppendResult(interp, buf, nullptr);
		return JIM_OK;
	}
	int retry = 0;
	while (_x.h && retry < 30)
	{
		retry++;
		Sleep(100);
	}
	if (_x.h)
	{
		Jim_AppendResult(interp, "busy", nullptr);
		return JIM_ERROR;
	}
	if (Jim_GetInt(interp, args[2], &_x.delay1)) return JIM_ERROR;
	if (Jim_GetInt(interp, args[3], &_x.delay2)) return JIM_ERROR;
	const char *filename = Jim_String(args[1]);
	_x.h = CreateFile(filename, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (!_x.h)
	{
		Jim_AppendResult(interp, "cannot open file: ", filename, nullptr);
		return JIM_ERROR;
	}
	HANDLE ev = CreateEvent(NULL, TRUE, FALSE, _x.evName);
	if (!ev)
	{
		Jim_AppendResult(interp, "cannot create event: ", _x.evName, nullptr);
		return JIM_ERROR;
	}
	_beginthread(win32_file_locker, 0, (void *)&_x);
	Sleep(0);
	DWORD wResult;
	if ((wResult = WaitForSingleObject(ev, 10000)) != WAIT_OBJECT_0)
	{
		__snprintf(buf, sizeof(buf), "0x%x", wResult);
		Jim_AppendResult(interp, "wait failed: ", buf, nullptr);
		CloseHandle(ev);
		return JIM_ERROR;
	}
	CloseHandle(ev);
	return JIM_OK;
}

#endif

//      optimization_control DB OPT BOOLEAN
//
// Enable or disable query optimizations using the sqlite3_test_control() interface.  Disable if BOOLEAN is false and enable if BOOLEAN is true.
// OPT is the name of the optimization to be disabled.
__constant__ static const struct
{
	const char *OptName;
	OPTFLAG Mask;
} _opts[] = {
	{ "all",              OPTFLAG_AllOpts        },
	{ "query-flattener",  OPTFLAG_QueryFlattener },
	{ "column-cache",     OPTFLAG_ColumnCache    },
	{ "groupby-order",    OPTFLAG_GroupByOrder   },
	{ "factor-constants", OPTFLAG_FactorOutConst },
	{ "real-as-int",      OPTFLAG_IdxRealAsInt   },
	{ "distinct-opt",     OPTFLAG_DistinctOpt    },
	{ "cover-idx-scan",   OPTFLAG_CoverIdxScan   },
	{ "order-by-idx-join",OPTFLAG_OrderByIdxJoin },
};
__device__ static int optimization_control(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[])
{
	if (argc != 4)
	{
		Jim_WrongNumArgs(interp, 1, args, "DB OPT BOOLEAN");
		return JIM_ERROR;
	}
	Context *ctx;
	bool onoff;
	if (GetDbPointer(interp, Jim_String(args[1]), &ctx)) return JIM_ERROR;
	if (Jim_GetBoolean(interp, args[3], &onoff)) return JIM_ERROR;
	const char *opt = Jim_String(args[2]);
	OPTFLAG mask = (OPTFLAG)0;
	int i;
	for (i = 0; i < _lengthof(_opts); i++)
	{
		if (!_strcmp(opt, _opts[i].OptName))
		{
			mask = _opts[i].Mask;
			break;
		}
	}
	if (onoff) mask = (OPTFLAG)~mask;
	if (i >= _lengthof(_opts))
	{
		Jim_AppendResult(interp, "unknown optimization - should be one of:", nullptr);
		for (i = 0; i < _lengthof(_opts); i++)
			Jim_AppendResult(interp, " ", _opts[i].OptName);
		return JIM_ERROR;
	}
	DataEx::TestControl(DataEx::TESTCTRL_OPTIMIZATIONS, ctx, mask);
	return JIM_OK;
}

#pragma endregion

#pragma region Register

extern __device__ int sqlite3_search_count;
extern __device__ int sqlite3_found_count;
extern __device__ int sqlite3_interrupt_count;
extern __device__ int sqlite3_open_file_count;
extern __device__ int sqlite3_sort_count;
extern __device__ int sqlite3_current_time;
#if OS_UNIX && defined(__APPLE__) && ENABLE_LOCKING_STYLE
extern __device__ int sqlite3_hostid_num;
#endif
extern __device__ int sqlite3_max_blobsize;
extern __device__ int sqlite3BtreeSharedCacheReport(ClientData clientData, Jim_Interp *interp, int argc, Jim_Obj *const args[]);
__constant__ static struct
{
	char *Name;
	Jim_CmdProc *Proc;
} _cmds[] = {
	{ "db_enter",						db_enter               },
	{ "db_leave",						db_leave               },
	{ "sqlite3_mprintf_int",			sqlite3_mprintf_int    },
	{ "sqlite3_mprintf_int64",			sqlite3_mprintf_int64  },
	{ "sqlite3_mprintf_long",			sqlite3_mprintf_long   },
	{ "sqlite3_mprintf_str",			sqlite3_mprintf_str    },
	{ "sqlite3_snprintf_str",			sqlite3_snprintf_str   },
	{ "sqlite3_mprintf_stronly",		sqlite3_mprintf_stronly},
	{ "sqlite3_mprintf_double",			sqlite3_mprintf_double },
	{ "sqlite3_mprintf_scaled",			sqlite3_mprintf_scaled },
	{ "sqlite3_mprintf_hexdouble",		sqlite3_mprintf_hexdouble},
	{ "sqlite3_mprintf_z_test",			test_mprintf_z        },
	{ "sqlite3_mprintf_n_test",			test_mprintf_n        },
	{ "sqlite3_snprintf_int",			test_snprintf_int     },
	{ "sqlite3_last_insert_rowid",		test_last_rowid       },
	{ "sqlite3_exec_printf",			test_exec_printf      },
	{ "sqlite3_exec_hex",				test_exec_hex         },
	{ "sqlite3_exec",					test_exec             },
	{ "sqlite3_exec_nr",				test_exec_nr          },
#ifndef OMIT_GET_TABLE
	{ "sqlite3_get_table_printf",		test_get_table_printf },
#endif
	{ "sqlite3_close",					sqlite_test_close     },
	{ "sqlite3_create_function",		test_create_function  },
	{ "sqlite3_create_aggregate",		test_create_aggregate },
	{ "sqlite_register_test_function",	test_register_func    },
	{ "sqlite_abort",					sqlite_abort          },
	{ "sqlite_bind",					test_bind             },
	{ "breakpoint",						test_breakpoint       },
	{ "sqlite3_key",					test_key              },
	{ "sqlite3_rekey",					test_rekey            },
	{ "sqlite_set_magic",				sqlite_set_magic      },
	{ "sqlite3_interrupt",				test_interrupt        },
	{ "sqlite_delete_function",			delete_function       },
	{ "sqlite_delete_collation",		delete_collation      },
	{ "sqlite3_get_autocommit",			get_autocommit        },
	{ "sqlite3_stack_used",				test_stack_used       },
	{ "sqlite3_busy_timeout",			test_busy_timeout     },
	{ "printf",							test_printf           },
	{ "sqlite3IoTrace",					test_io_trace         },
};
__constant__ static struct
{
	char *Name;
	Jim_CmdProc *Proc;
	ClientData ClientData;
} _objCmds[] = {
	{ "sqlite3_connection_pointer",		get_sqlite_pointer,		nullptr },
	{ "sqlite3_bind_int",				test_bind_int,			nullptr },
	{ "sqlite3_bind_zeroblob",			test_bind_zeroblob,		nullptr },
	{ "sqlite3_bind_int64",				test_bind_int64,		nullptr },
	{ "sqlite3_bind_double",			test_bind_double,		nullptr },
	{ "sqlite3_bind_null",				test_bind_null,			nullptr },
	{ "sqlite3_bind_text",				test_bind_text,			nullptr },
	{ "sqlite3_bind_text16",			test_bind_text16,		nullptr },
	{ "sqlite3_bind_blob",				test_bind_blob,			nullptr },
	{ "sqlite3_bind_parameter_count",	test_bind_parameter_count, nullptr },
	{ "sqlite3_bind_parameter_name",	test_bind_parameter_name,  nullptr },
	{ "sqlite3_bind_parameter_index",	test_bind_parameter_index, nullptr },
	{ "sqlite3_clear_bindings",			test_clear_bindings,	nullptr },
	{ "sqlite3_sleep",					test_sleep,				nullptr },
	{ "sqlite3_errcode",				test_errcode,			nullptr },
	{ "sqlite3_extended_errcode",		test_ex_errcode,		nullptr },
	{ "sqlite3_errmsg",					test_errmsg,			nullptr },
	{ "sqlite3_errmsg16",				test_errmsg16,			nullptr },
	{ "sqlite3_open",					test_open,				nullptr },
	{ "sqlite3_open16",					test_open16,			nullptr },
	{ "sqlite3_open_v2",				test_open_v2,			nullptr },
	{ "sqlite3_complete16",				test_complete16,		nullptr },

	{ "sqlite3_prepare",				test_prepare,			nullptr },
	{ "sqlite3_prepare16",				test_prepare16,			nullptr },
	{ "sqlite3_prepare_v2",				test_prepare_v2,		nullptr },
	{ "sqlite3_prepare_tkt3134",		test_prepare_tkt3134,	nullptr },
	{ "sqlite3_prepare16_v2",			test_prepare16_v2,		nullptr },
	{ "sqlite3_finalize",				test_finalize,			nullptr },
	{ "sqlite3_stmt_status",			test_stmt_status,		nullptr },
	{ "sqlite3_reset",					test_reset,				nullptr },
	{ "sqlite3_expired",				test_expired,			nullptr },
	{ "sqlite3_transfer_bindings",		test_transfer_bind,		nullptr },
	{ "sqlite3_changes",				test_changes,			nullptr },
	{ "sqlite3_step",					test_step,				nullptr },
	{ "sqlite3_sql",					test_sql,				nullptr },
	{ "sqlite3_next_stmt",				test_next_stmt,			nullptr },
	{ "sqlite3_stmt_readonly",			test_stmt_readonly,		nullptr },
	{ "sqlite3_stmt_busy",				test_stmt_busy,			nullptr },
	{ "uses_stmt_journal",				uses_stmt_journal,		nullptr },

	{ "sqlite3_release_memory",			test_release_memory,	nullptr },
	{ "sqlite3_db_release_memory",		test_db_release_memory,	nullptr },
	{ "sqlite3_db_filename",			test_db_filename,		nullptr },
	{ "sqlite3_db_readonly",			test_db_readonly,		nullptr },
	{ "sqlite3_soft_heap_limit",		test_soft_heap_limit,	nullptr },
	{ "sqlite3_thread_cleanup",			test_thread_cleanup,	nullptr },
	{ "sqlite3_pager_refcounts",		test_pager_refcounts,	nullptr },

	{ "sqlite3_load_extension",			test_load_extension,	nullptr },
	{ "sqlite3_enable_load_extension",	test_enable_load,		nullptr },
	{ "sqlite3_extended_result_codes",	test_extended_result_codes, nullptr },
	{ "sqlite3_limit",					test_limit,				nullptr },

	{ "save_prng_state",				save_prng_state,		nullptr },
	{ "restore_prng_state",				restore_prng_state,		nullptr },
	{ "reset_prng_state",				reset_prng_state,		nullptr },
	{ "optimization_control",			optimization_control,	nullptr},
#if OS_WIN
	{ "lock_win32_file",				win32_file_lock,		nullptr },
#endif
	{ "tcl_objproc",					runAsObjProc,			nullptr },

	// sqlite3_column_*() API
	{ "sqlite3_column_count",			test_column_count,		nullptr },
	{ "sqlite3_data_count",				test_data_count,		nullptr },
	{ "sqlite3_column_type",			test_column_type,		nullptr },
	{ "sqlite3_column_blob",			test_column_blob,		nullptr },
	{ "sqlite3_column_double",			test_column_double,		nullptr },
	{ "sqlite3_column_int64",			test_column_int64,		nullptr },
	{ "sqlite3_column_text",			test_stmt_utf8,			Vdbe::Column_Text },
	{ "sqlite3_column_name",			test_stmt_utf8,			Vdbe::Column_Name },
	{ "sqlite3_column_int",				test_stmt_int,			Vdbe::Column_Int  },
	{ "sqlite3_column_bytes",			test_stmt_int,			Vdbe::Column_Bytes},
#ifndef OMIT_DECLTYPE
	{ "sqlite3_column_decltype",		test_stmt_utf8,			Vdbe::Column_Decltype },
#endif
#ifdef ENABLE_COLUMN_METADATA
	{ "sqlite3_column_database_name",	test_stmt_utf8,			Vdbe::Column_database_name },
	{ "sqlite3_column_table_name",		test_stmt_utf8,			Vdbe::Column_table_name },
	{ "sqlite3_column_origin_name",		test_stmt_utf8,			Vdbe::Column_origin_name },
#endif

#ifndef OMIT_UTF16
	{ "sqlite3_column_bytes16",			test_stmt_int,			Vdbe::Column_Bytes16 },
	{ "sqlite3_column_text16",			test_stmt_utf16,		Vdbe::Column_Text16 },
	{ "sqlite3_column_name16",			test_stmt_utf16,		Vdbe::Column_Name16 },
	{ "add_alignment_test_collations",	add_alignment_test_collations, nullptr },
#ifndef OMIT_DECLTYPE
	{ "sqlite3_column_decltype16",		test_stmt_utf16,		Vdbe::Column_Decltype16 },
#endif
#ifdef ENABLE_COLUMN_METADATA
	{ "sqlite3_column_database_name16",	test_stmt_utf16, Vdbe::Column_database_name16 },
	{ "sqlite3_column_table_name16",	test_stmt_utf16, Vdbe::Column_table_name16 },
	{ "sqlite3_column_origin_name16",	test_stmt_utf16, Vdbe::Column_origin_name16 },
#endif
#endif
	{ "sqlite3_create_collation_v2",	test_create_collation_v2, nullptr },
	{ "sqlite3_global_recover",			test_global_recover,	nullptr },
	{ "working_64bit_int",				working_64bit_int,		nullptr },
	{ "vfs_unlink_test",				vfs_unlink_test,		nullptr },
	{ "vfs_initfail_test",				vfs_initfail_test,		nullptr },
	{ "vfs_unregister_all",				vfs_unregister_all,		nullptr },
	{ "vfs_reregister_all",				vfs_reregister_all,		nullptr },
	{ "file_control_test",				file_control_test,		nullptr },
	{ "file_control_lasterrno_test",	file_control_lasterrno_test,	nullptr },
	{ "file_control_lockproxy_test",	file_control_lockproxy_test,	nullptr },
	{ "file_control_chunksize_test",	file_control_chunksize_test,	nullptr },
	{ "file_control_sizehint_test",		file_control_sizehint_test,		nullptr },
	{ "file_control_win32_av_retry",	file_control_win32_av_retry,	nullptr },
	{ "file_control_persist_wal",		file_control_persist_wal,		nullptr },
	{ "file_control_powersafe_overwrite",file_control_powersafe_overwrite, nullptr },
	{ "file_control_vfsname",			file_control_vfsname,			nullptr },
	{ "file_control_tempfilename",		file_control_tempfilename,		nullptr },
	{ "sqlite3_vfs_list",				vfs_list,						nullptr },
	{ "sqlite3_create_function_v2",		test_create_function_v2,		nullptr },

	// Functions from os.h
#ifndef OMIT_UTF16
	{ "add_test_collate",				test_collate,			nullptr },
	{ "add_test_collate_needed",		test_collate_needed,	nullptr},
	{ "add_test_function",				test_function,			nullptr },
#endif
	{ "sqlite3_test_errstr",			test_errstr,			nullptr },
	{ "tcl_variable_type",				tcl_variable_type,		nullptr },
#ifndef OMIT_SHARED_CACHE
	{ "sqlite3_enable_shared_cache",	test_enable_shared,		nullptr },
	{ "sqlite3_shared_cache_report",	sqlite3BtreeSharedCacheReport, nullptr },
#endif
	{ "sqlite3_libversion_number",		test_libversion_number,	nullptr },
#ifdef ENABLE_COLUMN_METADATA
	{ "sqlite3_table_column_metadata",	test_table_column_metadata, nullptr },
#endif
#ifndef OMIT_INCRBLOB
	{ "sqlite3_blob_read",				test_blob_read,			nullptr },
	{ "sqlite3_blob_write",				test_blob_write,		nullptr },
	{ "sqlite3_blob_reopen",			test_blob_reopen,		nullptr },
	{ "sqlite3_blob_bytes",				test_blob_bytes,		nullptr },
	{ "sqlite3_blob_close",				test_blob_close,		nullptr },
#endif
	{ "pcache_stats",					test_pcache_stats,		nullptr },
#ifdef ENABLE_UNLOCK_NOTIFY
	{ "sqlite3_unlock_notify",			test_unlock_notify,		nullptr },
#endif
	{ "sqlite3_wal_checkpoint",			test_wal_checkpoint,	nullptr },
	{ "sqlite3_wal_checkpoint_v2",		test_wal_checkpoint_v2,	nullptr },
	{ "test_sqlite3_log",				test_sqlite3_log,		nullptr },
#ifndef OMIT_EXPLAIN
	{ "print_explain_query_plan",		test_print_eqp,			nullptr },
#endif
	{ "sqlite3_test_control",			test_test_control,		nullptr },
};
// Register commands with the TCL interpreter.
__constant__ static int bitmask_size = sizeof(Bitmask)*8;
extern __device__ int sqlite3_sync_count, sqlite3_fullsync_count;
extern __device__ int sqlite3_opentemp_count;
extern __device__ int sqlite3_like_count;
extern __device__ int sqlite3_xferopt_count;
extern __device__ int sqlite3_pager_readdb_count;
extern __device__ int sqlite3_pager_writedb_count;
extern __device__ int sqlite3_pager_writej_count;
#if OS_WIN
extern __device__ int sqlite3_os_type;
#endif
#ifdef _DEBUG
extern __device__ int sqlite3WhereTrace;
extern __device__ int sqlite3OSTrace;
extern __device__ int sqlite3WalTrace;
#endif
#ifdef _TEST
namespace CORE_NAME { extern __device__ char _queryPlan[]; }
__constant__ static char *query_plan = _queryPlan;
#ifdef ENABLE_FTS3
extern __device__ int sqlite3_fts3_enable_parentheses;
#endif
#endif
extern __device__ char *g_temp_directory;
extern __device__ char *g_data_directory;
__device__ int Sqlitetest1_Init(Jim_Interp *interp)
{
	int i;
	for (i = 0; i < _lengthof(_cmds); i++) Jim_CreateCommand(interp, _cmds[i].Name, _cmds[i].Proc, nullptr, nullptr);
	for (i = 0; i < _lengthof(_objCmds); i++) Jim_CreateCommand(interp, _objCmds[i].Name, _objCmds[i].Proc, _objCmds[i].ClientData, nullptr);
	Jim_LinkVar(interp, "sqlite_search_count", (char*)&sqlite3_search_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_found_count", (char*)&sqlite3_found_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_sort_count", (char*)&sqlite3_sort_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite3_max_blobsize", (char*)&sqlite3_max_blobsize, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_like_count", (char*)&sqlite3_like_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_interrupt_count", (char*)&sqlite3_interrupt_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_open_file_count", (char*)&sqlite3_open_file_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_current_time", (char*)&sqlite3_current_time, JIM_LINK_INT);
#if OS_UNIX && defined(__APPLE__) && ENABLE_LOCKING_STYLE
	Jim_LinkVar(interp, "sqlite_hostid_num", (char*)&sqlite3_hostid_num, JIM_LINK_INT);
#endif
	Jim_LinkVar(interp, "sqlite3_xferopt_count", (char*)&sqlite3_xferopt_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite3_pager_readdb_count", (char*)&sqlite3_pager_readdb_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite3_pager_writedb_count", (char*)&sqlite3_pager_writedb_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite3_pager_writej_count", (char*)&sqlite3_pager_writej_count, JIM_LINK_INT);
#ifndef OMIT_UTF16
	Jim_LinkVar(interp, "unaligned_string_counter", (char*)&_unaligned_string_counter, JIM_LINK_INT);
#endif
#ifndef OMIT_UTF16
	Jim_LinkVar(interp, "sqlite_last_needed_collation", (char*)&_neededCollation, JIM_LINK_STRING|JIM_LINK_READ_ONLY);
#endif
#if OS_WIN
	Jim_LinkVar(interp, "sqlite_os_type", (char*)&sqlite3_os_type, JIM_LINK_INT);
#endif
#ifdef _TEST
	Jim_LinkVar(interp, "sqlite_query_plan", (char*)&query_plan, JIM_LINK_STRING|JIM_LINK_READ_ONLY);
#endif
#ifdef _DEBUG
	Jim_LinkVar(interp, "sqlite_where_trace", (char*)&sqlite3WhereTrace, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_os_trace", (char*)&sqlite3OSTrace, JIM_LINK_INT);
#ifndef OMIT_WAL
	Jim_LinkVar(interp, "sqlite_wal_trace", (char*)&sqlite3WalTrace, JIM_LINK_INT);
#endif
#endif
#ifndef OMIT_DISKIO
	Jim_LinkVar(interp, "sqlite_opentemp_count", (char*)&sqlite3_opentemp_count, JIM_LINK_INT);
#endif
	Jim_LinkVar(interp, "sqlite_static_bind_value", (char*)&_static_bind_value, JIM_LINK_STRING);
	Jim_LinkVar(interp, "sqlite_static_bind_nbyte", (char*)&_static_bind_nbyte, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_temp_directory", (char*)&g_temp_directory, JIM_LINK_STRING);
	Jim_LinkVar(interp, "sqlite_data_directory", (char*)&g_data_directory, JIM_LINK_STRING);
	Jim_LinkVar(interp, "bitmask_size", (char*)&bitmask_size, JIM_LINK_INT|JIM_LINK_READ_ONLY);
	Jim_LinkVar(interp, "sqlite_sync_count", (char*)&sqlite3_sync_count, JIM_LINK_INT);
	Jim_LinkVar(interp, "sqlite_fullsync_count", (char*)&sqlite3_fullsync_count, JIM_LINK_INT);
#if defined(ENABLE_FTS3) && defined(_TEST)
	Jim_LinkVar(interp, "sqlite_fts3_enable_parentheses", (char*)&sqlite3_fts3_enable_parentheses, JIM_LINK_INT);
#endif
	return JIM_OK;
}

#pragma endregion